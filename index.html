<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>系統圖設計工具</title>
    <!-- 
    系統圖設計工具功能說明：
    1. 繪製功能：
       - 新增TB箱：建立矩形形狀的TB（Terminal Box）元件
       - 新增PA：建立圓形的PA（Power Amplifier）元件
       - 連接元件：選取兩個元件後按確認建立連線
       - 刪除：刪除所選元件或連線
       - 回復：復原上一步操作
    
    2. 編輯功能：
       - 輸入文字：編輯選中元件的名稱
       - 清除文字：清除選中元件的名稱
       - 拖曳元件：調整元件位置
       - 調整尺寸：使用控制點或滑桿調整元件大小
       - 選擇元件：點擊選取，Shift鍵多選，Ctrl鍵框選
       
    3. 背景管理：
       - 更換背景：上傳並設置背景圖片
       - 刪除背景：移除背景圖片
       - 調整透明度：設置背景圖片的透明度
       - 調整背景大小：使用控制點縮放或移動背景
       
    4. 檔案管理：
       - 開新檔：清空當前設計建立新檔案
       - 儲存：保存當前設計到本地
       - 載入：從已保存的設計中選擇載入
       - 匯入：從JSON檔案匯入設計
       - 匯出：將設計匯出為PDF檔案
       
    5. 組別管理：
       - 切換組別：在三個不同組別之間切換，每個組別有獨立的儲存空間
       
    6. 位置說明：
       - 位置說明表格：顯示並編輯TB箱與PA之間的位置關係說明
       - 自動生成表格：根據連接關係自動建立階層式表格
       
    7. 搜尋功能：
       - 按名稱搜尋：快速定位並高亮顯示匹配的元件
    -->
    <style>
        /* 位置說明提示框樣式 */
        .location-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 2000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            max-width: 300px;
            opacity: 0;
            transition: opacity 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .location-tooltip::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid rgba(0, 0, 0, 0.8);
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
        }
        .location-tooltip .title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #4CD964;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
            font-size: 16px;
        }
        .location-tooltip .desc {
            margin-top: 5px;
            white-space: pre-line;
        }
        .location-tooltip.show {
            opacity: 1;
        }
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .resizable-modal {
            resize: both;
            overflow: auto;
            min-width: 300px;
            min-height: 200px;
            max-width: 95vw;
            max-height: 95vh;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }
        .resizable-modal::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            background: linear-gradient(135deg, transparent 50%, rgba(255, 255, 255, 0.3) 50%);
            cursor: se-resize;
        }
        .location-table-header {
            background: #2d2d2d;
            color: white;
            padding: 12px;
            border-radius: 8px 8px 0 0;
            cursor: move;
            user-select: none;
        }
        .modal {
            background: rgba(45, 45, 45, 0.95);
            padding: 20px;
            border-radius: 12px;
            width: 250px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal h3 {
            color: white;
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 500;
        }
        .modal input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        .modal input:focus {
            background: rgba(255, 255, 255, 0.15);
            outline: none;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .modal button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .modal button.primary {
            background: rgba(0, 122, 255, 0.9);
            color: white;
        }
        .modal button.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .modal button.delete {
            background: rgba(255, 59, 48, 0.9);
            color: white;
        }
        .design-item {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }
        .design-item button.load {
            flex-grow: 1;
        }
        .design-item button.delete-design {
            padding: 8px;
            min-width: 32px;
        }
        .modal button:hover {
            transform: translateY(-1px);
        }
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            position: relative;
            background-color: #1a1a1a;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .toolbar {
            padding: 20px;
            background-color: rgba(30, 30, 30, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .toolbar button {
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            background: rgba(0, 122, 255, 0.9);
            color: white;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .toolbar button:hover {
            background: rgba(0, 122, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .toolbar button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }
        #canvas {
            border: none;
            background: #ffffff;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .selected {
            background: rgba(255, 59, 48, 0.7) !important;
            animation: selectPulse 1s infinite;
        }
        @keyframes selectPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .selection-box {
            position: absolute;
            border: 2px dashed #4CD964;
            background: rgba(76, 217, 100, 0.1);
            pointer-events: none;
            z-index: 1000;
        }
        .name-input-container {
            position: absolute;
            display: none;
            background: rgba(45, 45, 45, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            padding: 8px;
            min-width: 150px;
        }
        .name-input {
            padding: 8px 30px 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            width: 100%;
            box-sizing: border-box;
            outline: none;
            transition: background 0.2s ease;
        }
        .name-input:focus {
            background: rgba(255, 255, 255, 0.15);
        }
        .clear-button {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #333;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 1;
            padding: 0;
            border-radius: 50%;
        }
        .clear-button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        #delete {
            background: rgba(255, 59, 48, 0.9);
        }
        #delete:hover {
            background: rgba(255, 59, 48, 1);
        }
        #confirm {
            background: rgba(52, 199, 89, 0.9);
        }
        #confirm:hover {
            background: rgba(52, 199, 89, 1);
        }
    </style>
</head>
<body>
    <!-- 位置說明提示框 -->
    <div class="location-tooltip" id="locationTooltip">
        <div class="title"></div>
        <div class="desc"></div>
    </div>
    
    <div class="name-input-container">
        <input type="text" class="name-input" />
        <button class="clear-button">×</button>
    </div>
    <div class="modal-overlay" id="save-modal">
        <div class="modal">
            <h3>儲存設計</h3>
            <input type="text" id="save-input" placeholder="請輸入檔案名稱" />
            <div id="existing-designs" style="max-height: 200px; overflow-y: auto; margin: 10px 0;">
                <!-- 現有設計列表將由JavaScript動態填充 -->
            </div>
            <div class="modal-buttons">
                <button class="secondary" id="cancel-save">取消</button>
                <button class="primary" id="confirm-save">儲存</button>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="load-modal">
        <div class="modal">
            <h3>載入設計</h3>
            <div id="design-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
                <!-- 設計列表將由JavaScript動態填充 -->
            </div>
            <div class="modal-buttons">
                <button class="secondary" id="cancel-load">取消</button>
            </div>
        </div>
    </div>
    <div class="modal-overlay" id="location-desc-modal">
        <div class="modal resizable-modal" style="width: 750px;">
            <div class="location-table-header">
                <h3 style="margin: 0; padding: 0;">位置說明表格</h3>
            </div>
            <div id="location-table-container" style="max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
                <table id="location-table" style="width: 100%; border-collapse: collapse; color: white; font-size: 20px;">
                    <thead>
                        <tr>
                            <th style="border: 1px solid #000000; padding: 12px; text-align: center; font-size: 22px; width: 15%;">TB箱</th>
                            <th style="border: 1px solid #000000; padding: 12px; text-align: center; font-size: 22px; width: 30%;">PA編號</th>
                            <th style="border: 1px solid #000000; padding: 12px; text-align: center; font-size: 22px; width: 27%;">位置說明</th>
                            <th style="border: 1px solid #000000; padding: 12px; text-align: center; font-size: 22px; width: 28%;">TB位置備註</th>
                        </tr>
                    </thead>
                    <tbody id="location-table-body">
                        <!-- 表格內容將由JavaScript動態填充 -->
                    </tbody>
                </table>
            </div>
            <div class="modal-buttons">
                <button class="secondary" id="cancel-location-desc">關閉</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="search-modal">
        <div class="modal" style="width: 350px; position: absolute; top: 50px; left: 50px;">
            <div class="modal-header" style="cursor: move; padding: 12px; background: #2d2d2d; border-radius: 8px 8px 0 0;">
                <h3>搜尋PA或TB</h3>
            </div>
            <input type="text" id="search-input" placeholder="輸入PA或TB名稱關鍵字" />
            <div id="search-results" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px; color: white;">
                <!-- 搜尋結果將由JavaScript動態填充 -->
            </div>
            <div class="modal-buttons">
                <button class="secondary" id="cancel-search">取消</button>
                <button class="primary" id="confirm-search">搜尋</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="export-modal">
        <div class="modal" style="width: 350px; position: absolute; top: 50px; left: 50px;">
            <h3>匯出系統圖</h3>
            <input type="text" id="export-filename" placeholder="請輸入匯出檔案名稱" />
            <div style="margin: 15px 0; color: white;">
                <p style="margin-bottom: 8px;">選擇匯出格式：</p>
                <div style="display: flex; gap: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="export-format" value="pdf" checked style="margin-right: 5px;"> PDF
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio" name="export-format" value="jpg" style="margin-right: 5px;"> JPG
                    </label>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="secondary" id="cancel-export">取消</button>
                <button class="primary" id="confirm-export">匯出</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="add-pa-modal">
        <div class="modal" style="width: 350px; position: absolute; top: 50px; left: 50px;">
            <h3>新增PA</h3>
            <input type="text" id="pa-name-input" placeholder="請輸入PA名稱" />
            <div class="modal-buttons">
                <button class="secondary" id="cancel-add-pa">取消</button>
                <button class="primary" id="confirm-add-pa">確認</button>
            </div>
        </div>
    </div>
    
    <input type="file" id="bg-upload" accept="image/*" style="display: none;" />
    <div class="toolbar" style="display: flex; justify-content: space-between; position: relative;">
        <div class="current-filename" style="position: absolute; left: 50%; bottom: -5px; transform: translateX(-50%) translateY(100%); color: black; font-size: 16px; font-weight: 500; text-shadow: 0 2px 4px rgba(255,255,255,0.3); padding: 8px 16px; background: rgba(255,255,255,1); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">未命名檔案</div>
        <!-- 左邊功能 -->
        <div style="display: flex; gap: 10px; align-items: center;">
            
            <select id="group-select" style="padding: 12px; border-radius: 12px; background: rgba(255, 255, 255, 0.9); border: none; font-size: 15px; font-weight: 500;">
                <option value="group3">第三組</option>
                <option value="group2">第二組</option>
                <option value="group1">第一組</option>
            </select>
            <button id="new" style="background: rgba(255, 149, 0, 0.9);">開新檔</button>
            <button id="changeBg" style="background: rgba(88, 86, 214, 0.9);">更換背景</button>
            <button id="removeBg" style="background: rgba(255, 59, 48, 0.9);">刪除背景</button>
            <button id="rotateBg" style="background: rgba(88, 86, 214, 0.9);">旋轉背景</button>
            <div class="opacity-control" style="display: flex; align-items: center; gap: 8px; color: white;">
                <span>透明度:</span>
                <input type="range" id="bg-opacity" min="0" max="1" step="0.1" value="1" style="width: 100px;">
            </div>
        </div>
        <!-- 中間功能 -->
        <div style="display: flex; gap: 10px;">
            <button id="addTB">新增TB箱</button>
            <button id="addPA">新增PA</button>
            <button id="delete">刪除</button>
            <button id="confirm">確認</button>
            <button id="undo">回復</button>
            <button id="edit" style="background: rgba(52, 199, 89, 0.9);">輸入文字</button>
            <button id="clear" style="background: rgba(52, 199, 89, 0.9);">清除文字</button>
            <button id="locationDesc" style="background: rgba(88, 86, 214, 0.9);">位置說明</button>
            <div class="size-control" style="display: flex; align-items: center; gap: 8px; color: white;">
                <span>寬度:</span>
                <input type="range" id="shape-width" min="20" max="400" step="1" value="60" style="width: 100px;">
                <span>高度:</span>
                <input type="range" id="shape-height" min="20" max="200" step="1" value="60" style="width: 100px;">
            </div>
        </div>
        <!-- 右邊功能 -->
        <div style="display: flex; gap: 10px;">
            <button id="toggleTooltip" style="background: rgba(88, 86, 214, 0.9);">提示開關</button>
            <button id="search" style="background: rgba(255, 204, 0, 0.9);">搜尋</button>
            <button id="export" style="background: rgba(142, 142, 147, 0.9);">匯出</button>
            <button id="save" style="background: rgba(255, 149, 0, 0.9);">儲存</button>
            <button id="load" style="background: rgba(255, 149, 0, 0.9);">載入</button>
            <button id="import" style="background: rgba(255, 149, 0, 0.9);">匯入</button>
        </div>
    </div>
    <input type="file" id="json-upload" accept=".json" style="display: none;" />
    <div style="position: absolute; top: 10px; left: 10px; z-index: 9999;">
    <span id="zoom-level" style="color: black; font-size: 15px; font-weight: 500; min-width: 60px; text-align: center; background: rgba(255,255,255,0.7); padding: 2px 8px; border-radius: 4px;">100%</span>
</div>
<canvas id="canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // 初始化畫布和繪圖上下文
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const shapes = [];  // 存放所有元件的陣列
        let bgImage = null; // 背景圖片
        let bgOpacity = 1;  // 背景透明度
        let bgRotation = 0; // 背景旋轉角度 (0, 90, 180, 270)
        
        // 背景圖片緩存
        let bgCanvas = document.createElement('canvas');
        let bgCtx = bgCanvas.getContext('2d');
        let bgCacheDirty = true; // 標記背景緩存是否需要更新

        // 畫布縮放和位移相關變數
        let scale = 1;      // 縮放比例
        let offsetX = 0;    // X軸位移
        let offsetY = 0;    // Y軸位移
        let isPanning = false; // 是否正在拖曳畫布
        let lastPanX = 0;   // 上次拖曳的X座標
        let lastPanY = 0;   // 上次拖曳的Y座標

        // 背景透明度控制
        document.getElementById('bg-opacity').addEventListener('input', (e) => {
            bgOpacity = parseFloat(e.target.value);
            localStorage.setItem('bgOpacity', bgOpacity);
            bgCacheDirty = true; // 透明度變化時更新緩存
            redraw();
        });
        
        // 背景旋轉控制
        document.getElementById('rotateBg').addEventListener('click', () => {
            bgRotation = (bgRotation + 90) % 360;
            bgCacheDirty = true;
            console.log('旋轉角度:', bgRotation); // 添加日誌調試
            redraw();
        });

        // 背景圖片上傳功能
        document.getElementById('changeBg').addEventListener('click', () => {
            if (bgImage && !confirm('確定要更換背景圖片嗎？')) {
                return;
            }
            document.getElementById('bg-upload').click();
        });

        // 防止右鍵選單
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // 背景圖片調整相關變數
        let isResizingBg = false;  // 是否正在調整背景圖片大小
        let isDraggingBg = false;  // 是否正在拖動背景圖片
        let bgResizeHandle = null; // 背景調整控制點
        let bgResizeStartX = 0;    // 調整開始X座標
        let bgResizeStartY = 0;    // 調整開始Y座標
        let bgStartWidth = 0;      // 調整開始寬度
        let bgStartHeight = 0;     // 調整開始高度
        let bgStartX = 0;          // 調整開始X位置
        let bgStartY = 0;          // 調整開始Y位置

        // 檢查點擊是否在背景調整控制點上 (不受縮放和位移影響)
        function isPointInBgResizeHandle(x, y) {
            if (!bgImage) return null;
            const handleSize = 8;
            const handles = [
                { type: 'corner', x: bgImage.x + bgImage.displayWidth - handleSize/2, y: bgImage.y + bgImage.displayHeight - handleSize/2 },
                { type: 'right', x: bgImage.x + bgImage.displayWidth - handleSize/2, y: bgImage.y + bgImage.displayHeight/2 - handleSize/2 },
                { type: 'bottom', x: bgImage.x + bgImage.displayWidth/2 - handleSize/2, y: bgImage.y + bgImage.displayHeight - handleSize/2 },
                { type: 'center', x: bgImage.x + bgImage.displayWidth/2 - handleSize/2, y: bgImage.y + bgImage.displayHeight/2 - handleSize/2 }
            ];

            for (const handle of handles) {
                if (x >= handle.x && x <= handle.x + handleSize &&
                    y >= handle.y && y <= handle.y + handleSize) {
                    return handle.type;
                }
            }
            return null;
        }

        // 繪製背景調整控制點 (不受縮放影響)
        function drawBgResizeHandles() {
            if (!bgImage) return;
            const handleSize = 8;
            ctx.fillStyle = '#4CD964';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 4;
            // 右下角
            ctx.beginPath();
            ctx.arc(bgImage.x + bgImage.displayWidth, bgImage.y + bgImage.displayHeight, handleSize/2, 0, Math.PI * 2);
            ctx.fill();
            // 右邊中間
            ctx.beginPath();
            ctx.arc(bgImage.x + bgImage.displayWidth, bgImage.y + bgImage.displayHeight/2, handleSize/2, 0, Math.PI * 2);
            ctx.fill();
            // 下邊中間
            ctx.beginPath();
            ctx.arc(bgImage.x + bgImage.displayWidth/2, bgImage.y + bgImage.displayHeight, handleSize/2, 0, Math.PI * 2);
            ctx.fill();
            // 添加移動控制點（中心點）
            ctx.beginPath();
            ctx.arc(bgImage.x + bgImage.displayWidth/2, bgImage.y + bgImage.displayHeight/2, handleSize/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // 開新檔案功能
        document.getElementById('new').addEventListener('click', () => {
            if (shapes.length > 0 || bgImage) {
                if (!confirm('開新檔案將清除目前的設計，確定要繼續嗎？')) {
                    return;
                }
                shapes.length = 0;
                connections.length = 0;
                selectedShapes.length = 0;
                bgImage = null;
                localStorage.removeItem('bgImage');
                localStorage.removeItem('bgState');
                // 清除檔案名稱顯示
                document.querySelector('.current-filename').textContent = '未命名檔案';
                redraw();
            }
        });

        // 刪除背景功能
        document.getElementById('removeBg').addEventListener('click', () => {
            if (bgImage && confirm('確定要清除背景圖片嗎？')) {
                let opacity = 1;
                function fadeOut() {
                    opacity -= 0.05;
                    ctx.globalAlpha = opacity;
                    redraw();
                    ctx.globalAlpha = 1;
                    if (opacity > 0) {
                        requestAnimationFrame(fadeOut);
                    } else {
                        bgImage = null;
                        localStorage.removeItem('bgImage');
                        localStorage.removeItem('bgState');
                        redraw();
                    }
                }
                fadeOut();
            }
        });

        document.getElementById('bg-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const oldBgImage = bgImage;
                        bgImage = img;
                        // 設置初始顯示大小，確保圖片完整顯示並置中
                        const scaleWidth = canvas.width / img.width;
                        const scaleHeight = canvas.height / img.height;
                        const scale = Math.min(scaleWidth, scaleHeight) * 0.9; // 留出10%邊距
                        bgImage.displayWidth = img.width * scale;
                        bgImage.displayHeight = img.height * scale;
                        bgImage.x = (canvas.width - bgImage.displayWidth) / 2;
                        bgImage.y = (canvas.height - bgImage.displayHeight) / 2;
                        // 儲存背景圖片和狀態
                        localStorage.setItem('bgImage', event.target.result);
                        const bgState = {
                            opacity: bgOpacity,
                            displayWidth: bgImage.displayWidth,
                            displayHeight: bgImage.displayHeight,
                            x: bgImage.x,
                            y: bgImage.y
                        };
                        localStorage.setItem('bgState', JSON.stringify(bgState));
                        localStorage.setItem('bgOpacity', bgOpacity);
                        
                        // 標記背景緩存需要更新
                        bgCacheDirty = true;
                        
                        // 添加淡入效果
                        let opacity = 0;
                        function fadeIn() {
                            opacity += 0.05;
                            ctx.globalAlpha = opacity;
                            // 先繪製背景
                            if (bgImage) {
                                ctx.drawImage(bgImage, bgImage.x, bgImage.y, bgImage.displayWidth, bgImage.displayHeight);
                            }
                            redrawShapes();
                            drawBgResizeHandles();
                            drawResizeHandles();
                            ctx.globalAlpha = 1;

                            if (opacity < 1) {
                                requestAnimationFrame(fadeIn);
                            }
                        }
                        fadeIn();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // 元件選擇和操作相關變數
        let selectedShapes = [];  // 已選中的元件
        let isDragging = false;   // 是否正在拖動元件
        let isResizing = false;   // 是否正在調整元件大小
        let currentShape = null;  // 當前操作的元件
        let dragOffsetX = 0;      // 拖動偏移X
        let dragOffsetY = 0;      // 拖動偏移Y
        let connections = [];     // 元件之間的連線
        let history = [];         // 操作歷史記錄
        let isSelecting = false;  // 是否正在框選
        let selectionStartX = 0;  // 框選開始X
        let selectionStartY = 0;  // 框選開始Y
        let selectionBox = null;  // 框選區域元素

        // 創建框選盒
        function createSelectionBox() {
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            document.body.appendChild(selectionBox);
        }

        // 更新框選盒位置和大小
        function updateSelectionBox(x, y) {
            if (!selectionBox) return;
            const left = Math.min(x, selectionStartX);
            const top = Math.min(y, selectionStartY);
            const width = Math.abs(x - selectionStartX);
            const height = Math.abs(y - selectionStartY);
            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        // 移除框選盒
        function removeSelectionBox() {
            if (selectionBox) {
                selectionBox.remove();
                selectionBox = null;
            }
        }

        // 檢查元件是否在框選區域內
        function isShapeInSelectionBox(shape) {
            if (!selectionBox) return false;
            const box = selectionBox.getBoundingClientRect();
            const shapeCenter = {
                x: shape.x + shape.width / 2,
                y: shape.y + shape.height / 2
            };
            return shapeCenter.x >= box.left && shapeCenter.x <= box.right &&
                   shapeCenter.y >= box.top && shapeCenter.y <= box.bottom;
        }

        // 檢查連線是否在框選區域內
        function isConnectionInSelectionBox(connection) {
            if (!selectionBox) return false;
            const box = selectionBox.getBoundingClientRect();
            const midX = (connection.startX + connection.endX) / 2;
            const midY = (connection.startY + connection.endY) / 2;
            return midX >= box.left && midX <= box.right &&
                   midY >= box.top && midY <= box.bottom;
        }

        // 檔案名稱管理
        let currentFileName = '未命名檔案';
        function updateFileNameDisplay() {
          document.querySelector('.current-filename').textContent = currentFileName;
        }
        let lastClickTime = 0;
        let resizeHandle = null;
        
        // 設計儲存管理 - 按組別區分
        let savedDesigns = {
            group3: JSON.parse(localStorage.getItem('savedDesigns_group3') || '{}'),
            group2: JSON.parse(localStorage.getItem('savedDesigns_group2') || '{}'),
            group1: JSON.parse(localStorage.getItem('savedDesigns_group1') || '{}')
        };
        
        // 設定預設組別
        let currentGroup = 'group3';
        
        // 確保頁面載入時選擇器顯示正確的組別
        window.addEventListener('DOMContentLoaded', () => {
            document.getElementById('group-select').value = currentGroup;
        });

        // 組別選擇事件處理
        document.getElementById('group-select').addEventListener('change', (e) => {
            currentGroup = e.target.value;
            // 更新當前檔案名稱顯示
            currentFileName = '未命名檔案';
            updateFileNameDisplay();
        });

        // 支援 Shift 多選
        canvas.addEventListener('mousedown', function(e) {
            if (e.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 如果按住Ctrl鍵，開始框選
            if (e.ctrlKey) {
                isSelecting = true;
                selectionStartX = e.clientX;
                selectionStartY = e.clientY;
                createSelectionBox();
                return;
            }
            
            // 優先檢測可操作元件
            let hit = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
                if (shapes[i].isPointInside(x, y)) {
                    hit = true;
                    if (e.shiftKey) {
                        if (selectedShapes.includes(shapes[i])) {
                            selectedShapes = selectedShapes.filter(s => s !== shapes[i]);
                        } else {
                            selectedShapes.push(shapes[i]);
                        }
                    } else {
                        if (!selectedShapes.includes(shapes[i])) {
                            selectedShapes = [shapes[i]];
                        }
                    }
                    currentShape = shapes[i];
                    dragOffsetX = x - shapes[i].x;
                    dragOffsetY = y - shapes[i].y;
                    isDragging = true;
                    redraw();
                    break;
                }
            }
            
            // 如果沒有點擊到任何元件，觸發確認按鈕
            if (!hit) {
                document.getElementById('confirm').click();
            }
            
            // 點擊設計框空白處（非TB箱和PA圖示）等於按下確認鍵
            if (!hit && !isPointInTB(x, y) && !isPointInPA(x, y)) {
                document.getElementById('confirm').click();
            }

            // 未點擊到元件時處理背景操作
            if (!hit) {
                selectedShapes = [];
                redraw();
                if (bgImage && isPointInBg(x, y)) {
                    document.getElementById('confirm').click();
                }
            }
        });

        function isPointInBg(x, y) {
            return bgImage &&
                x >= bgImage.x &&
                x <= bgImage.x + bgImage.displayWidth &&
                y >= bgImage.y &&
                y <= bgImage.y + bgImage.displayHeight;
        }

        // 滑鼠移動事件 - 處理拖曳和框選
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isSelecting) {
                updateSelectionBox(e.clientX, e.clientY);
                return;
            }

            if (isDragging && selectedShapes.length > 0) {
                const dx = x - (currentShape.x + dragOffsetX);
                const dy = y - (currentShape.y + dragOffsetY);
                selectedShapes.forEach(shape => {
                    shape.x += dx;
                    shape.y += dy;
                });
                redraw();
                dragOffsetX += dx;
                dragOffsetY += dy;
            }
        });

        // 滑鼠放開事件 - 完成拖曳或框選
        canvas.addEventListener('mouseup', function(e) {
            if (isSelecting) {
                // 檢查框選區域內的元件
                shapes.forEach(shape => {
                    if (isShapeInSelectionBox(shape)) {
                        if (!selectedShapes.includes(shape)) {
                            selectedShapes.push(shape);
                        }
                    }
                });
                connections.forEach(connection => {
                    if (isConnectionInSelectionBox(connection)) {
                        if (!selectedShapes.includes(connection)) {
                            selectedShapes.push(connection);
                        }
                    }
                });
                isSelecting = false;
                removeSelectionBox();
                redraw();
            }
            if (isDragging) {
                isDragging = false;
                currentShape = null;
                // 更新位置說明表格
                const currentDesignName = localStorage.getItem('currentDesignName');
                generateLocationTable(currentDesignName);
            }
        });

        // 刪除多個選中的圖案
        function deleteSelectedShapes() {
            if (selectedShapes.length > 0) {
                shapes = shapes.filter(s => !selectedShapes.includes(s));
                selectedShapes = [];
                redraw();
                // 更新位置說明表格
                const currentDesignName = localStorage.getItem('currentDesignName');
                generateLocationTable(currentDesignName);
            }
        }

        // 刪除按鈕事件處理
        document.getElementById('delete').addEventListener('click', function() {
            deleteSelectedShapes();
        });

        // 鍵盤刪除事件處理
        document.addEventListener('keydown', function(e) {
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedShapes.length > 0) {
                deleteSelectedShapes();
            }
        });

        // 載入背景圖片（從 localStorage）
        const savedBgImage = localStorage.getItem('bgImage');
        const savedBgState = localStorage.getItem('bgState');
        if (savedBgImage) {
            const img = new Image();
            img.onload = () => {
                bgImage = img;
                if (savedBgState) {
                    const bgState = JSON.parse(savedBgState);
                    bgImage.displayWidth = bgState.displayWidth;
                    bgImage.displayHeight = bgState.displayHeight;
                    bgImage.x = bgState.x;
                    bgImage.y = bgState.y;
                }
                bgCacheDirty = true; // 圖片載入時標記緩存需更新
                redraw();
            };
            img.src = savedBgImage;
        }

        // 顯示保存對話框
        document.getElementById('save').addEventListener('click', () => {
            const designList = document.getElementById('existing-designs');
            designList.innerHTML = '';
            const names = Object.keys(savedDesigns[currentGroup]);
            
            // 預設當前文件名
            const currentFilename = document.querySelector('.current-filename').textContent;
            document.getElementById('save-input').value = currentFilename === '未命名檔案' ? '' : currentFilename;
            
            if (names.length > 0) {
                const title = document.createElement('div');
                title.style.color = 'white';
                title.style.marginBottom = '10px';
                title.textContent = '現有檔案：';
                designList.appendChild(title);

                names.forEach(name => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'design-item';
                    itemDiv.style.marginBottom = '5px';

                    const nameButton = document.createElement('button');
                    nameButton.className = 'primary load';
                    nameButton.textContent = name;
                    nameButton.style.flexGrow = '1';
                    nameButton.onclick = () => {
                        document.getElementById('save-input').value = name;
                        document.getElementById('save-input').focus();
                    };

                    itemDiv.appendChild(nameButton);
                    designList.appendChild(itemDiv);
                });
            }

            document.getElementById('save-modal').style.display = 'flex';
            document.getElementById('save-input').focus();
        });

        // 取消保存
        document.getElementById('cancel-save').addEventListener('click', () => {
            document.getElementById('save-modal').style.display = 'none';
            document.getElementById('save-input').value = '';
        });

        // 保存設計功能實現
        function saveDesign() {
            const name = document.getElementById('save-input').value.trim();
            if (!name) {
                alert('請輸入檔案名稱');
                return;
            }

            if (savedDesigns[currentGroup][name]) {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.innerHTML = `
                    <div class="modal">
                        <h3>檔案已存在</h3>
                        <div style="color: white; margin-bottom: 15px;">「${name}」已存在，請選擇處理方式：</div>
                        <div class="modal-buttons">
                            <button class="secondary" id="cancel-overwrite">取消</button>
                            <button class="primary" id="save-as-new">另存新檔</button>
                            <button class="delete" id="confirm-overwrite">覆蓋</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                document.getElementById('cancel-overwrite').onclick = () => {
                    document.body.removeChild(modal);
                };

                document.getElementById('save-as-new').onclick = () => {
                    document.body.removeChild(modal);
                    document.getElementById('save-input').value = name + ' - 複製';
                    document.getElementById('save-input').focus();
                };

                document.getElementById('confirm-overwrite').onclick = () => {
                    document.body.removeChild(modal);
                    saveDesignData(name);
                };
                return;
            }

            saveDesignData(name);
        }

        // 實際保存設計數據
        function saveDesignData(name) {
            // 獲取位置說明數據
            const locationDescData = {};
            const rows = document.querySelectorAll('#location-table-body tr');
            rows.forEach(row => {
                const tbName = row.querySelector('td:first-child').textContent;
                const paNameWithIndent = row.querySelector('td:nth-child(2)').textContent;
                const paName = paNameWithIndent.trimStart();
                const input = row.querySelector('td:nth-child(3) input');
                const tbLocationInput = row.querySelector('td:nth-child(4) input');
                
                if (!locationDescData[tbName]) {
                    locationDescData[tbName] = {};
                }
                
                // 保存位置說明和TB位置備註
                locationDescData[tbName][paName] = {
                    desc: input ? input.value : '',
                    tbLocation: tbLocationInput ? tbLocationInput.value : ''
                };
            });
            
            // 準備要保存的設計數據
            const designData = {
                shapes: shapes.map(shape => ({
                    type: shape.type,
                    x: shape.x,
                    y: shape.y,
                    width: shape.width,
                    height: shape.height,
                    name: shape.name
                })),
                connections: connections.map(conn => ({
                    start: shapes.indexOf(conn.start),
                    end: shapes.indexOf(conn.end)
                })),
                locationDesc: locationDescData,
                bgImage: bgImage ? {
                    data: localStorage.getItem('bgImage'),
                    state: JSON.parse(localStorage.getItem('bgState'))
                } : null
            };
            
            // 將設計數據保存為JSON檔案
            const jsonData = JSON.stringify(designData, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = name + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // 同時保存到當前組別的localStorage
            savedDesigns[currentGroup][name] = designData;
            localStorage.setItem(`savedDesigns_${currentGroup}`, JSON.stringify(savedDesigns[currentGroup]));
            document.getElementById('save-modal').style.display = 'none';
            document.getElementById('save-input').value = '';
            
            // 更新當前檔案名稱顯示
            currentFileName = name;
            updateFileNameDisplay();
            
            // 儲存當前設計名稱到localStorage
            localStorage.setItem('currentDesignName', name);
            
            // 顯示成功訊息
            alert('設計已成功儲存！');
        }

        // 確認保存按鈕點擊事件
        document.getElementById('confirm-save').addEventListener('click', () => {
          currentFileName = document.getElementById('save-input').value.trim() || '未命名設計';
          updateFileNameDisplay();
          saveDesign();
        });

        // 關閉視窗前詢問是否儲存
        window.addEventListener('beforeunload', (e) => {
            if (shapes.length > 0 || bgImage) {
                e.preventDefault();
                e.returnValue = '';
                return '';
            }
        });

        // 保存輸入框Enter鍵事件
        document.getElementById('save-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveDesign();
            }
        });

        // 載入保存的設計
        document.getElementById('load').addEventListener('click', () => {
            const designList = document.getElementById('design-list');
            designList.innerHTML = '';
            const names = Object.keys(savedDesigns[currentGroup]);
            
            if (names.length > 0) {
                names.forEach(name => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'design-item';

                    const loadButton = document.createElement('button');
                    loadButton.className = 'primary load';
                    loadButton.textContent = name;
                    loadButton.onclick = () => loadDesign(name);

                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete delete-design';
                    deleteButton.innerHTML = '×';
                    deleteButton.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm('確定要刪除「' + name + '」嗎？')) {
                            delete savedDesigns[currentGroup][name];
                            localStorage.setItem(`savedDesigns_${currentGroup}`, JSON.stringify(savedDesigns[currentGroup]));
                            itemDiv.remove();
                            if (Object.keys(savedDesigns[currentGroup]).length === 0) {
                                document.getElementById('load-modal').style.display = 'none';
                                alert('目前沒有已保存的設計');
                            }
                        }
                    };

                    itemDiv.appendChild(loadButton);
                    itemDiv.appendChild(deleteButton);
                    designList.appendChild(itemDiv);
                });
                
                // 居中顯示載入模態框
                const loadModal = document.getElementById('load-modal');
                loadModal.style.display = 'flex';
                loadModal.style.justifyContent = 'center';
                loadModal.style.alignItems = 'center';
            } else {
                alert('目前沒有已保存的設計');
            }
        });

        // 取消載入
        document.getElementById('cancel-load').addEventListener('click', () => {
            document.getElementById('load-modal').style.display = 'none';
        });

        // 匯入JSON檔案
        document.getElementById('import').addEventListener('click', () => {
            document.getElementById('json-upload').click();
        });

        // 處理JSON檔案上傳
        document.getElementById('json-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const designData = JSON.parse(event.target.result);
                        const fileName = file.name.replace('.json', '');
                        
                        // 檢查是否已存在同名設計
                        if (savedDesigns[currentGroup][fileName]) {
                            const modal = document.createElement('div');
                            modal.className = 'modal-overlay';
                            modal.style.display = 'flex';
                            modal.innerHTML = `
                                <div class="modal">
                                    <h3>檔案已存在</h3>
                                    <div style="color: white; margin-bottom: 15px;">「${fileName}」已存在，請選擇處理方式：</div>
                                    <div class="modal-buttons">
                                        <button class="secondary" id="cancel-import">取消</button>
                                        <button class="primary" id="import-as-new">另存新檔</button>
                                        <button class="delete" id="confirm-import">覆蓋</button>
                                    </div>
                                </div>
                            `;
                            document.body.appendChild(modal);

                            document.getElementById('cancel-import').onclick = () => {
                                document.body.removeChild(modal);
                            };

                            document.getElementById('import-as-new').onclick = () => {
                                document.body.removeChild(modal);
                                const newName = fileName + ' - 複製';
                                savedDesigns[currentGroup][newName] = designData;
                                localStorage.setItem(`savedDesigns_${currentGroup}`, JSON.stringify(savedDesigns[currentGroup]));
                                loadDesign(newName, designData);
                            };

                            document.getElementById('confirm-import').onclick = () => {
                                document.body.removeChild(modal);
                                savedDesigns[currentGroup][fileName] = designData;
                                localStorage.setItem(`savedDesigns_${currentGroup}`, JSON.stringify(savedDesigns[currentGroup]));
                                loadDesign(fileName, designData);
                            };
                        } else {
                            savedDesigns[currentGroup][fileName] = designData;
                            localStorage.setItem(`savedDesigns_${currentGroup}`, JSON.stringify(savedDesigns[currentGroup]));
                            loadDesign(fileName, designData);
                        }
                    } catch (error) {
                        alert('無法讀取JSON檔案，請確認檔案格式是否正確');
                    }
                };
                reader.readAsText(file);
            }
            // 清除input的value，這樣同一個檔案可以重複選擇
            e.target.value = '';
        });

        // 載入指定的設計
        function loadDesign(name, designData) {
            shapes.length = 0;
            connections.length = 0;
            selectedShapes.length = 0;

            // 如果沒有提供designData，從當前組別的savedDesigns中讀取
            if (!designData) {
                designData = savedDesigns[currentGroup][name];
            }

            // 重建圖形元件
            designData.shapes.forEach(shapeData => {
                const shape = new Shape(shapeData.type, shapeData.x, shapeData.y);
                shape.width = shapeData.width;
                shape.height = shapeData.height;
                shape.name = shapeData.name;
                shapes.push(shape);
            });

            // 重建連線
            designData.connections.forEach(conn => {
                connections.push({
                    start: shapes[conn.start],
                    end: shapes[conn.end]
                });
            });

            // 如果有背景圖片數據，載入背景圖片
            if (designData.bgImage) {
                const img = new Image();
                img.onload = () => {
                    bgImage = img;
                    const state = designData.bgImage.state;
                    bgImage.displayWidth = state.displayWidth;
                    bgImage.displayHeight = state.displayHeight;
                    bgImage.x = state.x;
                    bgImage.y = state.y;
                    localStorage.setItem('bgImage', designData.bgImage.data);
                    localStorage.setItem('bgState', JSON.stringify(state));
                    redraw();
                };
                img.src = designData.bgImage.data;
            }

            document.getElementById('load-modal').style.display = 'none';
            redraw();
            
            // 儲存當前載入的設計名稱
            localStorage.setItem('currentDesignName', name);
            currentFileName = name;
            updateFileNameDisplay();
            
            // 如果有位置說明數據，更新表格
            if (designData.locationDesc) {
                generateLocationTable(name);
            }
        }
        
        // 生成位置說明表格 - 顯示TB箱和相關連接的PA階層結構
        function generateLocationTable(designName) {
            const tableBody = document.getElementById('location-table-body');
            tableBody.innerHTML = '';
            tableBody.style.fontSize = '20px';
            tableBody.style.padding = '12px';
            
            // 獲取所有TB箱
            const tbShapes = shapes.filter(shape => shape.type === 'TB');
            
            // 對於每個TB箱，找出與其連接的PA及其下游PA
            tbShapes.forEach(tb => {
                // 找出與此TB箱直接連接的所有PA
                const connectedPAs = [];
                const processedPAs = new Set(); // 用於追踪已處理的PA
                
                // 遞迴函數，用於找出PA的所有下游PA
                function findDownstreamPAs(currentPA, depth = 0) {
                    if (processedPAs.has(currentPA)) return;
                    processedPAs.add(currentPA);
                    
                    // 將當前PA添加到列表中，包含深度信息
                    connectedPAs.push({ pa: currentPA, depth: depth });
                    
                    // 尋找與當前PA連接的下游PA
                    connections.forEach(conn => {
                        if (conn.start === currentPA && conn.end.type === 'PA') {
                            findDownstreamPAs(conn.end, depth + 1);
                        }
                    });
                }
                
                // 找出與TB箱直接連接的PA
                connections.forEach(conn => {
                    if (conn.start === tb && conn.end.type === 'PA') {
                        findDownstreamPAs(conn.end, 0);
                    } else if (conn.end === tb && conn.start.type === 'PA') {
                        findDownstreamPAs(conn.start, 0);
                    }
                });
                
                // 如果沒有連接的PA，也顯示TB箱
                if (connectedPAs.length === 0) {
                    const row = document.createElement('tr');
                    const tbName = tb.name || 'TB';
                    row.innerHTML = `
                        <td style="border: 1px solid #000000; padding: 12px; font-size: 20px;">${tbName}</td>
                        <td style="border: 1px solid #000000; padding: 12px; font-size: 20px;">-</td>
                        <td style="border: 1px solid #000000; padding: 12px;">
                            <input type="text" style="width: 100%; background: rgba(255,255,255,0.1); border: none; color: white; padding: 8px; font-size: 20px;" placeholder="請輸入位置說明" data-tb="${tbName}" data-pa="-">
                        </td>
                        <td style="border: 1px solid #000000; padding: 12px;">
                            <input type="text" style="width: 100%; background: rgba(255,255,255,0.1); border: none; color: white; padding: 8px; font-size: 20px;" placeholder="請輸入TB位置備註" data-tb="${tbName}" data-pa="-" data-type="tblocation">
                        </td>
                    `;
                    tableBody.appendChild(row);
                } else {
                    // 為每個連接的PA創建一行，包括下游PA
                    connectedPAs.forEach(({ pa, depth }, index) => {
                        const row = document.createElement('tr');
                        const indent = '　'.repeat(depth); // 使用全形空格進行縮排
                        const tbName = tb.name || 'TB';
                        const paName = pa.name || 'PA';
                        
                        // 根據深度決定是否顯示TB位置備註輸入框
                        const tbLocationCell = depth === 0 ? 
                            `<input type="text" style="width: 100%; background: rgba(255,255,255,0.1); border: none; color: white; padding: 8px; font-size: 20px;" placeholder="請輸入TB位置備註" data-tb="${tbName}" data-pa="${paName}" data-type="tblocation">` :
                            `<span style="color: white;">-</span>`;
                        
                        row.innerHTML = `
                            <td style="border: 1px solid #000000; padding: 12px; font-size: 20px;">${tbName}</td>
                            <td style="border: 1px solid #000000; padding: 12px; font-size: 20px;">${indent}${paName}</td>
                            <td style="border: 1px solid #000000; padding: 12px;">
                                <input type="text" style="width: 100%; background: rgba(255,255,255,0.1); border: none; color: white; padding: 8px; font-size: 20px;" placeholder="請輸入位置說明" data-tb="${tbName}" data-pa="${paName}">
                            </td>
                            <td style="border: 1px solid #000000; padding: 12px;">
                                ${tbLocationCell}
                            </td>
                        `;
                        tableBody.appendChild(row);
                    });
                }
            });
            
            // 填充已保存的位置說明
            let locationDesc = null;
            
            // 如果提供了設計名稱參數，直接使用
            if (designName && savedDesigns[currentGroup][designName] && savedDesigns[currentGroup][designName].locationDesc) {
                locationDesc = savedDesigns[currentGroup][designName].locationDesc;
            } else {
                // 嘗試從localStorage獲取當前設計名稱
                const currentDesignName = localStorage.getItem('currentDesignName');
                if (currentDesignName && savedDesigns[currentGroup][currentDesignName] && savedDesigns[currentGroup][currentDesignName].locationDesc) {
                    locationDesc = savedDesigns[currentGroup][currentDesignName].locationDesc;
                }
            }
            
            // 如果找到了位置說明數據，填充表格
            if (locationDesc) {
                const rows = tableBody.querySelectorAll('tr');
                
                rows.forEach(row => {
                    const tbName = row.querySelector('td:first-child').textContent;
                    const paNameWithIndent = row.querySelector('td:nth-child(2)').textContent;
                    const paName = paNameWithIndent.trimStart();
                    const input = row.querySelector('td:nth-child(3) input');
                    const tbLocationInput = row.querySelector('td:nth-child(4) input');
                    
                    if (locationDesc[tbName] && locationDesc[tbName][paName]) {
                        // 設置位置說明
                        if (input) {
                            input.value = locationDesc[tbName][paName].desc || '';
                        }
                        
                        // 設置TB位置備註（只有第一層PA才有輸入框）
                        if (tbLocationInput) {
                            tbLocationInput.value = locationDesc[tbName][paName].tbLocation || '';
                        }
                    }
                });
            }

            // 為表格所有輸入框添加自動儲存和即時更新功能
            tableBody.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', () => {
                    syncLocationDescInputs();
                });
                
                input.addEventListener('change', () => {
                    syncLocationDescInputs();
                });
                
                // 取得輸入框的資料屬性
                const tbName = input.getAttribute('data-tb');
                const paName = input.getAttribute('data-pa');
                const isLocation = input.getAttribute('data-type') === 'tblocation';
                
                // 設定初始值（如果已有位置說明資料）
                if (tbName && paName) {
                    const currentDesignName = localStorage.getItem('currentDesignName');
                    if (currentDesignName && savedDesigns[currentGroup][currentDesignName] && 
                        savedDesigns[currentGroup][currentDesignName].locationDesc) {
                        const locationDesc = savedDesigns[currentGroup][currentDesignName].locationDesc;
                        
                        if (locationDesc[tbName] && locationDesc[tbName][paName]) {
                            if (isLocation) {
                                input.value = locationDesc[tbName][paName].tbLocation || '';
                            } else {
                                input.value = locationDesc[tbName][paName].desc || '';
                            }
                        }
                    }
                }
            });
        }
        
        // 初始化位置說明表格的拖曳功能
        const locationModal = document.getElementById('location-desc-modal');
        const locationModalContent = locationModal.querySelector('.modal');
        const header = locationModal.querySelector('.location-table-header');
        let isDraggingModal = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let modalStartX = 0;
        let modalStartY = 0;

        // 設置初始樣式
        locationModal.style.position = 'fixed';
        locationModal.style.margin = '0';
        locationModal.style.display = 'none';
        locationModal.style.justifyContent = 'center';
        locationModal.style.alignItems = 'center';

        // 設置header的樣式
        header.style.cursor = 'move';
        header.style.userSelect = 'none';
        header.style.padding = '12px';
        header.style.backgroundColor = 'rgba(45, 45, 45, 0.95)';
        header.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
        header.style.borderRadius = '12px 12px 0 0';

        header.addEventListener('mousedown', (e) => {
            isDraggingModal = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // 獲取當前位置
            const rect = locationModalContent.getBoundingClientRect();
            modalStartX = rect.left;
            modalStartY = rect.top;
            
            e.preventDefault(); // 防止文字選擇
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingModal) return;
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            
            locationModalContent.style.position = 'fixed';
            locationModalContent.style.left = modalStartX + dx + 'px';
            locationModalContent.style.top = modalStartY + dy + 'px';
            locationModalContent.style.margin = '0';
            locationModalContent.style.transform = 'none';
        });

        document.addEventListener('mouseup', () => {
            isDraggingModal = false;
        });

        // 位置說明按鈕點擊事件
        document.getElementById('locationDesc').addEventListener('click', () => {
            const currentDesignName = localStorage.getItem('currentDesignName');
            generateLocationTable(currentDesignName);
            
            locationModal.style.display = 'flex';
            
            // 只在第一次打開或未設置位置時置中顯示
            const modalContent = locationModal.querySelector('.modal');
            if (!modalContent.style.position || modalContent.style.position !== 'fixed') {
                modalContent.style.position = 'relative'; // 使用相對定位以便在flex布局中居中
                modalContent.style.left = '';
                modalContent.style.top = '';
                modalContent.style.margin = '0 auto';
            }
        });
        
        // 關閉位置說明對話框
        document.getElementById('cancel-location-desc').addEventListener('click', () => {
            document.getElementById('location-desc-modal').style.display = 'none';
        });
        
        // 當添加新的TB或PA時，更新位置說明表格
        document.getElementById('addTB').addEventListener('click', () => {
            const tb = new Shape('TB', canvas.width / 2, canvas.height / 2);
            shapes.push(tb);
            selectedShapes = [tb];
            redraw();
            const currentDesignName = localStorage.getItem('currentDesignName');
            generateLocationTable(currentDesignName);
        });
        
        // 新增PA功能
        document.getElementById('addPA').addEventListener('click', () => {
            document.getElementById('add-pa-modal').style.display = 'flex';
            document.getElementById('pa-name-input').value = '';
            document.getElementById('pa-name-input').focus();
        });

        document.getElementById('cancel-add-pa').addEventListener('click', () => {
            document.getElementById('add-pa-modal').style.display = 'none';
        });

        document.getElementById('pa-name-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('confirm-add-pa').click();
            }
        });

        document.getElementById('confirm-add-pa').addEventListener('click', () => {
            const modal = document.getElementById('add-pa-modal');
            const input = document.getElementById('pa-name-input');
            const paName = input.value.trim();
            
            if (paName) {
                const pa = new Shape('PA', canvas.width / 2, canvas.height / 2);
                pa.name = paName;
                pa.width = 120;// 原PA尺寸100px放大20%
                pa.height = 60;// 原PA尺寸50px放大20%
                shapes.push(pa);
                selectedShapes = [pa];
                redraw();
                const currentDesignName = localStorage.getItem('currentDesignName');
                generateLocationTable(currentDesignName);
            }
            
            modal.style.display = 'none';
            input.value = '';
        });
        
        // 當確認連接時，更新位置說明表格
        document.getElementById('confirm').addEventListener('click', () => {
            const currentDesignName = localStorage.getItem('currentDesignName');
            generateLocationTable(currentDesignName);
        });
        
        // 當刪除元素時，更新位置說明表格
        document.getElementById('delete').addEventListener('click', () => {
            if (document.getElementById('location-desc-modal').style.display === 'flex') {
                const currentDesignName = localStorage.getItem('currentDesignName');
                setTimeout(() => generateLocationTable(currentDesignName), 100);
            }
        });
        
        // 搜尋模態框拖曳功能
let isDraggingSearch = false;
let searchStartX = 0;
let searchStartY = 0;
let searchModalX = 0;
let searchModalY = 0;

document.querySelector('#search-modal .modal-header').addEventListener('mousedown', (e) => {
    isDraggingSearch = true;
    const rect = e.target.closest('.modal').getBoundingClientRect();
    searchStartX = e.clientX;
    searchStartY = e.clientY;
    searchModalX = rect.left;
    searchModalY = rect.top;
    e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
    if (isDraggingSearch) {
        const dx = e.clientX - searchStartX;
        const dy = e.clientY - searchStartY;
        const modal = document.querySelector('#search-modal .modal');
        modal.style.left = `${searchModalX + dx}px`;
        modal.style.top = `${searchModalY + dy}px`;
    }
});

document.addEventListener('mouseup', () => {
    isDraggingSearch = false;
});

// 搜尋按鈕點擊事件 - 開啟搜尋對話框
        document.getElementById('search').addEventListener('click', () => {
            document.getElementById('search-modal').style.display = 'flex';
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').innerHTML = '';
            document.getElementById('search-input').focus();
        });
        
        // 關閉搜尋模態框
        document.getElementById('cancel-search').addEventListener('click', () => {
            document.getElementById('search-modal').style.display = 'none';
            // 清除高亮顯示
            selectedShapes = [];
            redraw();
        });
        
        // 搜尋功能實現
        document.getElementById('confirm-search').addEventListener('click', performSearch);
        
        // 搜尋輸入框Enter鍵事件
        document.getElementById('search-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
        
        // 執行搜尋 - 根據關鍵字尋找匹配的元件
        function performSearch() {
            const keyword = document.getElementById('search-input').value.trim().toLowerCase();
            if (!keyword) {
                alert('請輸入搜尋關鍵字');
                return;
            }
            
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '';
            
            // 清除之前的選擇
            selectedShapes = [];
            
            // 搜尋匹配的形狀
            const matchedShapes = shapes.filter(shape => {
                return shape.name && shape.name.toLowerCase().includes(keyword);
            });
            
            if (matchedShapes.length === 0) {
                resultsDiv.innerHTML = '<div style="padding: 10px; text-align: center;">沒有找到匹配的結果</div>';
                redraw();
                return;
            }
            
            // 顯示搜尋結果並高亮匹配的形狀
            matchedShapes.forEach(shape => {
                const resultItem = document.createElement('div');
                resultItem.style.padding = '8px';
                resultItem.style.margin = '5px 0';
                resultItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                resultItem.style.borderRadius = '4px';
                resultItem.style.cursor = 'pointer';
                resultItem.innerHTML = `<strong>${shape.type}:</strong> ${shape.name || '未命名'}`;
                
                // 點擊結果項目時，高亮顯示對應的形狀
                resultItem.addEventListener('click', () => {
                    selectedShapes = [shape];
                    redraw();
                });
                
                resultsDiv.appendChild(resultItem);
                
                // 將匹配的形狀添加到選中列表，以高亮顯示
                selectedShapes.push(shape);
            });
            
            // 重繪畫布，高亮顯示匹配的形狀
            redraw();
        }
        
        // 匯出按鈕點擊事件 - 開啟匯出對話框
        document.getElementById('export').addEventListener('click', () => {
            const exportModal = document.getElementById('export-modal');
            exportModal.style.display = 'flex';
            document.getElementById('export-filename').value = currentFileName;
            document.getElementById('export-filename').focus();
        });
        
        // 關閉匯出模態框
        document.getElementById('cancel-export').addEventListener('click', () => {
            document.getElementById('export-modal').style.display = 'none';
        });
        
        // 匯出功能實現
        document.getElementById('confirm-export').addEventListener('click', exportDesign);
        
        // 匯出輸入框Enter鍵事件
        document.getElementById('export-filename').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                exportDesign();
            }
        });
        
        // 執行匯出 - 將設計匯出為PDF或JPG檔案
        function exportDesign() {
            let filename = document.getElementById('export-filename').value.trim();
            if (!filename) {
                filename = currentFileName;
            }
            
            // 獲取選擇的匯出格式
            const format = document.querySelector('input[name="export-format"]:checked').value;
            
            if (format === 'pdf') {
                exportAsPdf(filename);
            } else if (format === 'jpg') {
                exportAsJpg(filename);
            }
            
            // 關閉匯出模態框
            document.getElementById('export-modal').style.display = 'none';
        }
        
        // 匯出為JPG - 分別匯出系統圖和位置說明表格
        async function exportAsJpg(filename) {
            // 顯示加載提示
            const loadingDiv = document.createElement('div');
            loadingDiv.style.position = 'fixed';
            loadingDiv.style.top = '0';
            loadingDiv.style.left = '0';
            loadingDiv.style.width = '100%';
            loadingDiv.style.height = '100%';
            loadingDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
            loadingDiv.style.display = 'flex';
            loadingDiv.style.justifyContent = 'center';
            loadingDiv.style.alignItems = 'center';
            loadingDiv.style.zIndex = '9999';
            loadingDiv.innerHTML = '<div style="color: white; font-size: 24px; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;">正在生成JPG，請稍候...</div>';
            document.body.appendChild(loadingDiv);
            
            // 隱藏工具欄和其他UI元素
            const toolbar = document.querySelector('.toolbar');
            const originalToolbarDisplay = toolbar.style.display;
            toolbar.style.display = 'none';
            
            // 創建系統圖容器
            const designContainer = document.createElement('div');
            designContainer.style.backgroundColor = '#ffffff';
            designContainer.style.padding = '20px';
            designContainer.style.width = canvas.width + 'px';
            designContainer.style.position = 'fixed';
            designContainer.style.top = '0';
            designContainer.style.left = '0';
            designContainer.style.zIndex = '-1';
            
            // 添加系統圖標題
            const title = document.createElement('h1');
            title.textContent = filename + ' - 系統圖';
            title.style.color = 'black';
            title.style.textAlign = 'center';
            title.style.marginBottom = '20px';
            designContainer.appendChild(title);
            
            // 將畫布添加到容器
            const canvasImage = document.createElement('img');
            canvasImage.width = canvas.width;
            canvasImage.height = canvas.height;
            designContainer.appendChild(canvasImage);
            document.body.appendChild(designContainer);
            
            // 使用html2canvas捕獲畫布內容
            const canvasImg = await html2canvas(canvas);
            canvasImage.src = canvasImg.toDataURL('image/png');
            await new Promise(resolve => setTimeout(resolve, 300)); // 等待圖片載入
            
            // 生成系統圖JPG
            const designImg = await html2canvas(designContainer, {
                backgroundColor: '#FFFFFF',
                scale: 2, // 提高輸出質量
                useCORS: true,
                logging: false
            });
            
            // 創建系統圖下載連結
            const designLink = document.createElement('a');
            designLink.href = designImg.toDataURL('image/jpeg', 0.9);
            designLink.download = filename + '_系統圖.jpg';
            document.body.appendChild(designLink);
            designLink.click();
            document.body.removeChild(designLink);
            document.body.removeChild(designContainer);
            
            // 生成位置說明表格
            generateLocationTable();
            const originalTable = document.getElementById('location-table');
            const allRows = originalTable.querySelectorAll('tbody tr');
            
            // 每頁顯示25筆資料
            const rowsPerPage = 25;
            const totalPages = Math.ceil(allRows.length / rowsPerPage);
            
            // 處理位置說明表格（分頁顯示）
            for (let page = 0; page < totalPages; page++) {
                const pageNum = page + 1;
                
                // 建立表格容器
                const tableContainer = document.createElement('div');
                tableContainer.style.backgroundColor = '#ffffff';
                tableContainer.style.padding = '20px';
                tableContainer.style.width = '100%';
                tableContainer.style.maxWidth = '1200px';
                tableContainer.style.position = 'fixed';
                tableContainer.style.top = '0';
                tableContainer.style.left = '0';
                tableContainer.style.zIndex = '-1';
                
                // 添加位置說明表格標題（包含頁碼）
                const tableTitle = document.createElement('h1');
                tableTitle.textContent = `${filename} - 位置說明 (第 ${pageNum} 頁，共 ${totalPages} 頁)`;
                tableTitle.style.color = 'black';
                tableTitle.style.textAlign = 'center';
                tableTitle.style.marginBottom = '20px';
                tableContainer.appendChild(tableTitle);
                
                // 建立新表格
                const pageTbl = document.createElement('table');
                pageTbl.style.width = '100%';
                pageTbl.style.marginTop = '20px';
                pageTbl.style.borderCollapse = 'collapse';
                pageTbl.style.color = '#000000';
                pageTbl.style.backgroundColor = '#ffffff';
                
                // 複製表頭
                const thead = originalTable.querySelector('thead').cloneNode(true);
                pageTbl.appendChild(thead);
                
                // 建立表格內容
                const tbody = document.createElement('tbody');
                const startIdx = page * rowsPerPage;
                const endIdx = Math.min(startIdx + rowsPerPage, allRows.length);
                
                // 添加當前頁的資料列
                for (let i = startIdx; i < endIdx; i++) {
                    const row = allRows[i].cloneNode(true);
                    tbody.appendChild(row);
                }
                
                pageTbl.appendChild(tbody);
                
                // 處理表格中的輸入框
                pageTbl.querySelectorAll('input').forEach(input => {
                    // 如果值是undefined、null、[object Object]或空物件，設為空字串
                    if (input.value === undefined || 
                        input.value === null || 
                        input.value === '[object Object]' || 
                        (typeof input.value === 'object' && input.value !== null)) {
                        input.value = '';
                    }
                    input.setAttribute('value', input.value);
                });
                
                // 設置表格單元格樣式
                pageTbl.querySelectorAll('th, td').forEach(cell => {
                    cell.style.border = '1px solid #000000';
                    cell.style.padding = '12px'; // 增加內邊距
                    cell.style.textAlign = 'center';
                    cell.style.color = '#000000'; // 確保所有文字為黑色
                    cell.style.fontSize = '20px'; // 增加字型大小到20px
                    
                    // 處理內容中的數字和英文，使其加粗
                    if (cell.textContent) {
                        const text = cell.textContent;
                        let processedText = '';
                        
                        // 逐字符處理，找出數字和英文字母
                        for (let i = 0; i < text.length; i++) {
                            const char = text[i];
                            // 檢查是否為數字或英文字母
                            if (/[0-9a-zA-Z]/.test(char)) {
                                // 加粗數字和英文
                                processedText += `<strong>${char}</strong>`;
                            } else {
                                processedText += char;
                            }
                        }
                        
                        // 如果有處理過的內容，替換原內容
                        if (processedText !== text) {
                            cell.innerHTML = processedText;
                        }
                    }
                });
                
                // 特別處理表頭，使其更醒目
                pageTbl.querySelectorAll('th').forEach(th => {
                    th.style.backgroundColor = '#f2f2f2'; // 淡灰色背景
                    th.style.fontSize = '20px'; // 表頭字型更大
                    th.style.fontWeight = '900'; // 極粗體
                });
                
                // 將表格添加到容器
                tableContainer.appendChild(pageTbl);
                document.body.appendChild(tableContainer);
                
                // 生成當前頁的位置說明表格JPG
                const tableImg = await html2canvas(tableContainer, {
                    backgroundColor: '#FFFFFF',
                    onclone: (clonedDoc) => {
                        clonedDoc.querySelectorAll('*').forEach(el => {
                            if (el.tagName === 'INPUT') {
                                // 如果輸入值是undefined、null、[object Object]或空物件，設為空字串
                                if (el.value === undefined || 
                                    el.value === null || 
                                    el.value === '[object Object]' || 
                                    (typeof el.value === 'object' && el.value !== null)) {
                                    el.value = '';
                                }
                                
                                // 將input元素轉換為純文字，並處理數字和英文
                                const text = el.value;
                                const textContainer = document.createElement('span');
                                textContainer.style.color = '#000000';  // 確保文字為黑色
                                textContainer.style.fontSize = '20px';  // 放大字型到20px
                                
                                // 處理數字和英文，使其加粗
                                let processedText = '';
                                for (let i = 0; i < text.length; i++) {
                                    const char = text[i];
                                    if (/[0-9a-zA-Z]/.test(char)) {
                                        // 加粗數字和英文
                                        processedText += `<strong>${char}</strong>`;
                                    } else {
                                        processedText += char;
                                    }
                                }
                                
                                textContainer.innerHTML = processedText;
                                el.parentNode.replaceChild(textContainer, el);
                            }
                            
                            // 確保所有文字為黑色且放大
                            el.style.color = '#000000';
                            el.style.backgroundColor = '#FFFFFF';
                            
                            // 增加文字大小
                            if (el.tagName !== 'TH' && 
                                el.tagName !== 'H1' && 
                                !el.closest('th') && 
                                el.style.fontSize === '') {
                                el.style.fontSize = '20px';
                            }
                        });
                    },
                    scale: 2, // 提高輸出質量
                    useCORS: true,
                    logging: false
                });
                
                // 創建位置說明表格下載連結
                const tableLink = document.createElement('a');
                tableLink.href = tableImg.toDataURL('image/jpeg', 0.9);
                tableLink.download = `${filename}_位置說明_第${pageNum}頁.jpg`;
                document.body.appendChild(tableLink);
                tableLink.click();
                document.body.removeChild(tableLink);
                document.body.removeChild(tableContainer);
                
                // 在多頁表格生成之間添加短暫延遲，避免瀏覽器過載
                if (page < totalPages - 1) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            // 清理DOM並恢復UI
            document.body.removeChild(loadingDiv);
            toolbar.style.display = originalToolbarDisplay;
            
            // 若有多頁顯示完成訊息
            if (totalPages > 1) {
                alert(`位置說明表格已分成 ${totalPages} 頁匯出完成！`);
            }
        }
        
        // 匯出為PDF - 包含系統圖和位置說明表格
        async function exportAsPdf(filename) {
            // 顯示加載提示
            const loadingDiv = document.createElement('div');
            loadingDiv.style.position = 'fixed';
            loadingDiv.style.top = '0';
            loadingDiv.style.left = '0';
            loadingDiv.style.width = '100%';
            loadingDiv.style.height = '100%';
            loadingDiv.style.backgroundColor = 'rgba(0,0,0,0.7)';
            loadingDiv.style.display = 'flex';
            loadingDiv.style.justifyContent = 'center';
            loadingDiv.style.alignItems = 'center';
            loadingDiv.style.zIndex = '9999';
            loadingDiv.innerHTML = '<div style="color: white; font-size: 24px; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;">正在生成PDF，請稍候...</div>';
            document.body.appendChild(loadingDiv);
            
            // 隱藏工具欄和其他UI元素
            const toolbar = document.querySelector('.toolbar');
            const originalToolbarDisplay = toolbar.style.display;
            toolbar.style.display = 'none';
            
            // 生成位置說明表格
            generateLocationTable();
            // 取得目前畫面上的表格
            const locationTable = document.getElementById('location-table').cloneNode(true);
            
            // 將 input 的 value 屬性設成目前的 value，避免[object Object]的顯示
            locationTable.querySelectorAll('input').forEach(input => {
                // 如果值是undefined、null、[object Object]或空物件，設為空字串
                if (input.value === undefined || 
                    input.value === null || 
                    input.value === '[object Object]' || 
                    (typeof input.value === 'object' && input.value !== null)) {
                    input.value = '';
                }
                input.setAttribute('value', input.value);
            });
            
            // --- PDF A4 尺寸設定 ---
            const pdfWidth = 794; // px, A4 portrait
            const pdfHeight = 1123; // px, A4 portrait
            
            // --- 系統圖頁面 ---
            const designContainer = document.createElement('div');
            designContainer.style.backgroundColor = '#ffffff';
            designContainer.style.padding = '5px 15px'; // 左右邊距設為15px，與PDF邊距協調
            designContainer.style.width = canvas.width + 'px';
            
            // 添加標題
            const title = document.createElement('h1');
            title.textContent = filename;
            title.style.color = 'black';
            title.style.textAlign = 'center';
            title.style.margin = '5px 0'; // 減少標題佔用的垂直空間
            designContainer.appendChild(title);
            
            // 將畫布添加到容器
            const canvasImage = document.createElement('img');
            canvasImage.width = canvas.width;
            canvasImage.height = canvas.height;
            designContainer.appendChild(canvasImage);
            document.body.appendChild(designContainer);
            
            // 使用html2canvas捕獲畫布內容
            const canvasImg = await html2canvas(canvas);
            canvasImage.src = canvasImg.toDataURL('image/png');
            await new Promise(resolve => setTimeout(resolve, 300)); // 等待圖片載入
            const designImg = await html2canvas(designContainer, {
                backgroundColor: '#FFFFFF',
                onclone: (clonedDoc) => {
                    clonedDoc.querySelectorAll('*').forEach(el => {
                        el.style.color = '#000000';
                        el.style.backgroundColor = '#FFFFFF';
                    });
                },
                scale: 1,
                useCORS: true,
                logging: false
            });
            // 創建PDF - 設置最小邊界
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: designImg.width > designImg.height ? 'landscape' : 'portrait',
                unit: 'px',
                format: [designImg.width, designImg.height],
                margins: {
                    top: 0,
                    right: 10,
                    bottom: 0,
                    left: 10
                }
            });
            // 添加設計圖到第一頁
            pdf.addImage(
                designImg.toDataURL('image/png'),
                'PNG',
                0,
                0,
                designImg.width,
                designImg.height
            );

            // --- 表格分頁 - 將位置說明表格分頁添加到PDF ---
            const rows = locationTable.querySelectorAll('tbody tr');
            const rowsPerPage = 25; // 每頁顯示行數，增加為25筆資料
            const totalPages = Math.ceil(rows.length / rowsPerPage);
            
            // 為每一頁創建表格
            for (let page = 0; page < totalPages; page++) {
                // 創建表格容器 (A4尺寸)
                const tableContainer = document.createElement('div');
                tableContainer.style.backgroundColor = '#fff';
                tableContainer.style.width = pdfWidth + 'px';
                tableContainer.style.height = pdfHeight + 'px';
                tableContainer.style.padding = '10px 15px 5px 15px'; // 調整左右邊距為15px，與PDF邊距協調
                tableContainer.style.boxSizing = 'border-box';
                tableContainer.style.overflow = 'hidden';

                // 標題
                const tableTitle = document.createElement('h1');
                tableTitle.textContent = `位置說明表格 (第 ${page + 2} 頁)`;
                tableTitle.style.color = 'black';
                tableTitle.style.textAlign = 'center';
                tableTitle.style.margin = '2px 0 5px 0'; // 進一步縮小標題上下邊距
                tableTitle.style.fontSize = '20px'; // 更小的標題字體
                tableContainer.appendChild(tableTitle);

                // 表格
                const currentTable = document.createElement('table');
                currentTable.style.width = '100%';
                currentTable.style.fontSize = '16px'; // 因增加每頁筆數，適當縮小字體
                currentTable.style.borderCollapse = 'collapse';
                currentTable.style.tableLayout = 'fixed';
                currentTable.style.backgroundColor = '#fff';

                // 設定欄位寬度
                const colgroup = document.createElement('colgroup');
                const col1 = document.createElement('col');
                col1.style.width = '15%'; // TB欄位縮小
                const col2 = document.createElement('col');
                col2.style.width = '30%'; // PA編號欄位增加5%
                const col3 = document.createElement('col');
                col3.style.width = '27%'; // 位置說明欄位縮小10%（原本30%）
                const col4 = document.createElement('col');
                col4.style.width = '28%'; // TB位置備註欄位縮小10%（原本30%）
                colgroup.appendChild(col1);
                colgroup.appendChild(col2);
                colgroup.appendChild(col3);
                colgroup.appendChild(col4);
                currentTable.appendChild(colgroup);

                // 複製表頭
                const thead = locationTable.querySelector('thead').cloneNode(true);
                // 強化表頭樣式
                thead.querySelectorAll('th').forEach(th => {
                    th.style.fontWeight = '900'; // 使用更粗的字體權重
                    th.style.backgroundColor = '#f2f2f2'; // 淡灰色背景，增強對比
                });
                currentTable.appendChild(thead);

                // 當前頁的行
                const tbody = document.createElement('tbody');
                const startRow = page * rowsPerPage;
                const endRow = Math.min(startRow + rowsPerPage, rows.length);
                for (let i = startRow; i < endRow; i++) {
                    const row = rows[i].cloneNode(true);
                    // 移除輸入框的 placeholder
                    const input = row.querySelector('input');
                    if (input) {
                        input.removeAttribute('placeholder');
                        // 確保輸入值不是[object Object]
                        if (input.value === undefined || 
                            input.value === null || 
                            input.value === '[object Object]' || 
                            (typeof input.value === 'object' && input.value !== null)) {
                            input.value = '';
                            input.setAttribute('value', '');
                        }
                    }
                    
                    // 處理TB位置備註欄位 - 確保顯示正確的值
                    const tbLocationInput = row.querySelector('td:nth-child(4) input');
                    if (tbLocationInput) {
                        // 確保輸入值不是[object Object]
                        if (tbLocationInput.value === undefined || 
                            tbLocationInput.value === null || 
                            tbLocationInput.value === '[object Object]' || 
                            (typeof tbLocationInput.value === 'object' && tbLocationInput.value !== null)) {
                            tbLocationInput.value = '';
                            tbLocationInput.setAttribute('value', '');
                        }
                    }
                    
                    tbody.appendChild(row);
                }
                currentTable.appendChild(tbody);
                tableContainer.appendChild(currentTable);
                document.body.appendChild(tableContainer);

                // 設定th, td樣式
                tableContainer.querySelectorAll('th, td').forEach(cell => {
                    cell.style.border = '1px solid #000';
                    cell.style.padding = '4px'; // 縮小單元格內邊距
                    cell.style.wordBreak = 'break-all';
                    cell.style.fontSize = '16px'; // 因增加每頁筆數，適當縮小字體
                    cell.style.fontWeight = 'bold'; // 文字加粗顯示
                    cell.style.backgroundColor = '#fff';
                    cell.style.color = '#000'; // 確保所有文字為黑色
                });

                // 設定輸入框樣式
                tableContainer.querySelectorAll('input').forEach(input => {
                    input.style.color = '#000'; // 添加黑色文字顏色
                    input.style.fontWeight = 'bold'; // 文字加粗顯示
                    input.style.backgroundColor = '#fff'; // 設定白色背景
                });

                // 確保所有文字為黑色
                tableContainer.querySelectorAll('*').forEach(el => {
                    el.style.color = '#000';
                });

                // 等待圖片產生
                await new Promise(resolve => setTimeout(resolve, 100));
                const tableImg = await html2canvas(tableContainer, {
                    backgroundColor: '#fff',
                    width: pdfWidth,
                    height: pdfHeight,
                    onclone: (clonedDoc) => {
                        clonedDoc.querySelectorAll('*').forEach(el => {
                            if (el.tagName === 'INPUT') {
                                // 如果輸入值是undefined、null、[object Object]或空物件，設為空字串
                                if (el.value === undefined || 
                                    el.value === null || 
                                    el.value === '[object Object]' || 
                                    (typeof el.value === 'object' && el.value !== null)) {
                                    el.value = '';
                                }
                                // 將input元素轉換為純文字
                                const text = document.createTextNode(el.value);
                                const textContainer = document.createElement('span');
                                textContainer.style.color = '#000000';  // 確保文字為黑色
                                textContainer.style.fontWeight = 'bold'; // 確保文字為粗體
                                textContainer.appendChild(text);
                                el.parentNode.replaceChild(textContainer, el);
                            }
                            // 確保所有文字為黑色
                            el.style.color = '#000000';
                            el.style.backgroundColor = '#FFFFFF';
                        });
                    },
                    scale: 1,
                    useCORS: true,
                    logging: false
                });
                pdf.addPage([pdfWidth, pdfHeight], 'portrait');
                pdf.addImage(
                    tableImg.toDataURL('image/png'),
                    'PNG',
                    0,
                    0,
                    pdfWidth,
                    pdfHeight
                );
                document.body.removeChild(tableContainer);
            }
            pdf.save(filename + '.pdf');
            document.body.removeChild(designContainer);
            document.body.removeChild(loadingDiv);
            toolbar.style.display = originalToolbarDisplay;
        }
        
        // 執行匯入


        // 調整畫布大小 - 隨視窗大小自動調整
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redraw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // 位置說明提示功能
        const locationTooltip = document.getElementById('locationTooltip');
        let currentHoveredShape = null;
        let tooltipEnabled = true; // 預設啟用提示
        
        // 提示開關按鈕功能
        document.getElementById('toggleTooltip').addEventListener('click', () => {
            tooltipEnabled = !tooltipEnabled;
            const btn = document.getElementById('toggleTooltip');
            
            if (tooltipEnabled) {
                btn.textContent = '提示開啟';
                btn.style.background = 'rgba(52, 199, 89, 0.9)'; // 綠色
                // 顯示短暫的通知
                const notification = document.createElement('div');
                notification.textContent = '位置提示功能已開啟';
                notification.style.position = 'fixed';
                notification.style.bottom = '20px';
                notification.style.left = '50%';
                notification.style.transform = 'translateX(-50%)';
                notification.style.backgroundColor = 'rgba(52, 199, 89, 0.9)';
                notification.style.color = 'white';
                notification.style.padding = '10px 20px';
                notification.style.borderRadius = '8px';
                notification.style.zIndex = '2000';
                notification.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
                document.body.appendChild(notification);
                
                // 2秒後自動消失
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => document.body.removeChild(notification), 500);
                }, 2000);
            } else {
                btn.textContent = '提示關閉';
                btn.style.background = 'rgba(142, 142, 147, 0.9)'; // 灰色
                // 隱藏當前顯示的提示框
                locationTooltip.classList.remove('show');
                currentHoveredShape = null;
                
                // 顯示短暫的通知
                const notification = document.createElement('div');
                notification.textContent = '位置提示功能已關閉';
                notification.style.position = 'fixed';
                notification.style.bottom = '20px';
                notification.style.left = '50%';
                notification.style.transform = 'translateX(-50%)';
                notification.style.backgroundColor = 'rgba(142, 142, 147, 0.9)';
                notification.style.color = 'white';
                notification.style.padding = '10px 20px';
                notification.style.borderRadius = '8px';
                notification.style.zIndex = '2000';
                notification.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
                document.body.appendChild(notification);
                
                // 2秒後自動消失
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => document.body.removeChild(notification), 500);
                }, 2000);
            }
        });
        
        // 設置初始按鈕狀態
        document.addEventListener('DOMContentLoaded', () => {
            const btn = document.getElementById('toggleTooltip');
            btn.textContent = '提示開啟';
            btn.style.background = 'rgba(52, 199, 89, 0.9)'; // 綠色
        });
        
        // 監聽滑鼠移動事件，顯示位置說明
        canvas.addEventListener('mousemove', (e) => {
            // 如果提示功能被關閉，不顯示提示
            if (!tooltipEnabled) return;
            
            if (isDragging || isResizing || isPanning || isSelecting) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 檢查滑鼠是否在某個形狀上
            let hoveredShape = null;
            for (const shape of shapes) {
                if (shape.isPointInside(x, y)) {
                    hoveredShape = shape;
                    break;
                }
            }
            
            // 如果滑鼠移動到新的形狀上
            if (hoveredShape !== currentHoveredShape) {
                currentHoveredShape = hoveredShape;
                
                if (hoveredShape) {
                    // 獲取位置說明
                    const locationInfo = hoveredShape.getLocationDescription();
                    if (locationInfo) {
                        // 設置提示框內容
                        const titleElement = locationTooltip.querySelector('.title');
                        const descElement = locationTooltip.querySelector('.desc');
                        
                        if (locationInfo.type === 'TB') {
                            titleElement.textContent = `${locationInfo.tbName} 位置備註`;
                            let content = '';
                            if (locationInfo.tbLocation) {
                                content += `${locationInfo.tbLocation}`;
                            }
                            // 顯示連接的TB箱
                            if (locationInfo.connectedTBs && locationInfo.connectedTBs.length > 0) {
                                if (content) content += '\n';
                                content += `連接的TB箱：${locationInfo.connectedTBs.join(', ')}`;
                            }
                            descElement.textContent = content || '尚無位置備註';
                        } else {
                            titleElement.textContent = `${locationInfo.paName || hoveredShape.name} 位置說明`;
                            let content = '';
                            
                            // 顯示連接的上一個PA編號
                            if (locationInfo.connectedPAs && locationInfo.connectedPAs.length > 0) {
                                content += `連接的上一個PA: `;
                                locationInfo.connectedPAs.forEach((pa, index) => {
                                    if (index > 0) content += ', ';
                                    content += pa.name;
                                });
                                content += '\n';
                            }
                            
                            if (locationInfo.desc) {
                                content += `位置說明：${locationInfo.desc}\n`;
                            }
                            
                            if (locationInfo.tbName) {
                                if (locationInfo.tbLocation) {
                                    content += `連接TB：${locationInfo.tbName}\nTB位置備註：${locationInfo.tbLocation}`;
                                } else {
                                    content += `連接TB：${locationInfo.tbName}`;
                                }
                            }
                            
                            descElement.textContent = content || '尚無位置說明';
                        }
                        
                        // 顯示提示框在滑鼠位置
                        locationTooltip.style.left = (e.clientX + 15) + 'px';
                        locationTooltip.style.top = (e.clientY - 15) + 'px';
                        locationTooltip.classList.add('show');
                    } else {
                        // 沒有位置說明，顯示默認信息
                        const titleElement = locationTooltip.querySelector('.title');
                        const descElement = locationTooltip.querySelector('.desc');
                        
                        if (hoveredShape.type === 'TB') {
                            titleElement.textContent = `${hoveredShape.name || 'TB'} 位置備註`;
                            descElement.textContent = '尚未設定位置備註';
                        } else {
                            titleElement.textContent = `${hoveredShape.name || 'PA'} 位置說明`;
                            
                            // 即使沒有位置說明，也嘗試顯示連接的PA
                            const connectedPAs = hoveredShape.getConnectedPAs();
                            if (connectedPAs && connectedPAs.length > 0) {
                                let content = `連接的上一個PA: `;
                                connectedPAs.forEach((pa, index) => {
                                    if (index > 0) content += ', ';
                                    content += pa.name;
                                });
                                descElement.textContent = content;
                            } else {
                                descElement.textContent = '尚未設定位置說明';
                            }
                        }
                        
                        locationTooltip.style.left = (e.clientX + 15) + 'px';
                        locationTooltip.style.top = (e.clientY - 15) + 'px';
                        locationTooltip.classList.add('show');
                    }
                } else {
                    // 如果滑鼠不在任何形狀上，隱藏提示框
                    locationTooltip.classList.remove('show');
                }
            } else if (hoveredShape) {
                // 如果仍在同一形狀上，但滑鼠位置變化，更新提示框位置
                locationTooltip.style.left = (e.clientX + 15) + 'px';
                locationTooltip.style.top = (e.clientY - 15) + 'px';
            }
        });
        
        // 離開畫布時隱藏提示框
        canvas.addEventListener('mouseleave', () => {
            locationTooltip.classList.remove('show');
            currentHoveredShape = null;
        });

        // 清除按鈕點擊事件
        document.querySelector('.clear-button').addEventListener('click', (e) => {
            const input = document.querySelector('.name-input');
            input.value = '';
            input.focus();
        });

        // 保存當前狀態到歷史記錄
        function saveState() {
            history.push({
                shapes: shapes.map(shape => ({
                    ...shape,
                    type: shape.type,
                    x: shape.x,
                    y: shape.y,
                    width: shape.width,
                    height: shape.height,
                    name: shape.name
                })),
                connections: connections.map(conn => ({
                    start: shapes.indexOf(conn.start),
                    end: shapes.indexOf(conn.end)
                }))
            });
        }

        // 從歷史記錄恢復狀態
        function restoreState(state) {
            shapes.length = 0;
            connections.length = 0;
            selectedShapes.length = 0;

            state.shapes.forEach(shapeData => {
                const shape = new Shape(shapeData.type, shapeData.x, shapeData.y);
                shape.name = shapeData.name;
                shape.width = shapeData.width;
                shape.height = shapeData.height;
                shapes.push(shape);
            });

            state.connections.forEach(connData => {
                connections.push({
                    start: shapes[connData.start],
                    end: shapes[connData.end]
                });
            });

            redraw();
        }

        // 圖形元件類別定義
        class Shape {
            constructor(type, x, y) {
                this.type = type;       // 類型：'TB' 或 'PA'
                this.x = x;             // X 座標
                this.y = y;             // Y 座標
                const baseSize = 60;    // 基礎大小
                if (type === 'TB') {
                    this.width = baseSize;
                    this.height = baseSize;
                } else {
                    this.width = baseSize * 1.2;  // PA寬度為TB的1.2倍
                    this.height = baseSize * 0.8; // PA高度為TB的0.8倍
                }
                // 預設名稱：TB類型自動編號，PA為空
                this.name = type === 'TB' ? type + (shapes.filter(s => s.type === type).length + 1) : '';
                this.isEditing = false;
            }

            // 繪製元件
            draw() {
                ctx.beginPath();
                if (this.type === 'TB') {
                    // TB為圓角矩形
                    const radius = 10; // 導角半徑
                    ctx.moveTo(this.x + radius, this.y);
                    ctx.lineTo(this.x + this.width - radius, this.y);
                    ctx.arcTo(this.x + this.width, this.y, this.x + this.width, this.y + radius, radius);
                    ctx.lineTo(this.x + this.width, this.y + this.height - radius);
                    ctx.arcTo(this.x + this.width, this.y + this.height, this.x + this.width - radius, this.y + this.height, radius);
                    ctx.lineTo(this.x + radius, this.y + this.height);
                    ctx.arcTo(this.x, this.y + this.height, this.x, this.y + this.height - radius, radius);
                    ctx.lineTo(this.x, this.y + radius);
                    ctx.arcTo(this.x, this.y, this.x + radius, this.y, radius);
                } else {
                    // PA為圓形
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.height/2, 0, Math.PI * 2);
                }
                // 選中狀態特殊顯示
                if (selectedShapes.includes(this)) {
                    ctx.strokeStyle = '#FF3B30';
                    ctx.lineWidth = 4;
                    
                    // 繪製調整大小的控制點
                    const handleSize = 8;
                    ctx.fillStyle = '#FF3B30';
                    // 右下角
                    ctx.fillRect(this.x + this.width - handleSize/2, this.y + this.height - handleSize/2, handleSize, handleSize);
                    // 右邊中間
                    ctx.fillRect(this.x + this.width - handleSize/2, this.y + this.height/2 - handleSize/2, handleSize, handleSize);
                    // 下邊中間
                    ctx.fillRect(this.x + this.width/2 - handleSize/2, this.y + this.height - handleSize/2, handleSize, handleSize);
                } else {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                }
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.stroke();

                // 繪製元件名稱
                if (this.name) {
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 18px -apple-system, BlinkMacSystemFont'; // 粗體12px字型
                    ctx.textAlign = 'center';
                    ctx.fillText(this.name, this.x + this.width/2, this.y + this.height/2);
                }
            }

            // 檢查點是否在元件內
            isPointInside(x, y) {
                // 將滑鼠座標轉換為畫布座標系
                const canvasX = (x - offsetX) / scale;
                const canvasY = (y - offsetY) / scale;
                
                if (this.type === 'TB') {
                    // TB為矩形區域
                    return canvasX >= this.x && canvasX <= this.x + this.width &&
                           canvasY >= this.y && canvasY <= this.y + this.height;
                } else {
                    // PA為圓形區域
                    const centerX = this.x + this.width/2;
                    const centerY = this.y + this.height/2;
                    const radius = this.height/2;
                    const distance = Math.sqrt((canvasX - centerX) ** 2 + (canvasY - centerY) ** 2);
                    return distance <= radius;
                }
            }
            
            // 獲取該元件的位置說明
            getLocationDescription() {
                const currentDesignName = localStorage.getItem('currentDesignName');
                if (!currentDesignName) return null;
                const locationDesc = savedDesigns[currentGroup]?.[currentDesignName]?.locationDesc;
                if (!locationDesc) return null;
                // 尋找相關的位置說明
                for (const tbName in locationDesc) {
                    // 如果是TB箱本身
                    if (this.type === 'TB' && (this.name === tbName || tbName === 'TB' + this.name)) {
                        // 取得所有與此TB連接的TB
                        const connectedTBs = [];
                        connections.forEach(conn => {
                            if (conn.start === this && conn.end.type === 'TB') {
                                connectedTBs.push(conn.end.name);
                            } else if (conn.end === this && conn.start.type === 'TB') {
                                connectedTBs.push(conn.start.name);
                            }
                        });
                        // 優先檢查是否有無關聯PA的TB箱位置說明（使用'-'作為鍵）
                        if (locationDesc[tbName]['-']) {
                            return {
                                type: 'TB',
                                tbName: tbName,
                                tbLocation: locationDesc[tbName]['-'].tbLocation || '',
                                desc: locationDesc[tbName]['-'].desc || '',
                                connectedTBs: connectedTBs
                            };
                        }
                        // 如果沒有，則檢查所有與此TB相關的PA
                        for (const paName in locationDesc[tbName]) {
                            const desc = locationDesc[tbName][paName];
                            if (paName === '-' || paName === '') {
                                // 這是TB本身的說明
                                return {
                                    type: 'TB',
                                    tbName: tbName,
                                    tbLocation: desc.tbLocation || '',
                                    desc: desc.desc || '',
                                    connectedTBs: connectedTBs
                                };
                            }
                            // 如果有任何PA連接到這個TB，使用第一個找到的TB位置備註
                            if (desc.tbLocation) {
                                return {
                                    type: 'TB',
                                    tbName: tbName,
                                    tbLocation: desc.tbLocation || '',
                                    desc: '',
                                    connectedTBs: connectedTBs
                                };
                            }
                        }
                    }
                    
                    // 如果是PA
                    if (this.type === 'PA') {
                        for (const paName in locationDesc[tbName]) {
                            if (this.name === paName || paName === 'PA' + this.name) {
                                // 查找連接到這個PA的上一個PA
                                const connectedPAs = this.getConnectedPAs();
                                
                                return {
                                    type: 'PA',
                                    tbName: tbName,
                                    paName: paName,
                                    desc: locationDesc[tbName][paName].desc || '',
                                    tbLocation: locationDesc[tbName][paName].tbLocation || '',
                                    connectedPAs: connectedPAs
                                };
                            }
                        }
                    }
                }
                
                // 如果在位置說明中找不到，但是是PA型別，仍然回傳連接PA的資訊
                if (this.type === 'PA') {
                    const connectedPAs = this.getConnectedPAs();
                    if (connectedPAs.length > 0) {
                        return {
                            type: 'PA',
                            paName: this.name,
                            connectedPAs: connectedPAs
                        };
                    }
                }
                
                return null;
            }
            
            // 獲取與當前PA直接連接的所有上一個PA
            getConnectedPAs() {
                // 如果不是PA，返回空數組
                if (this.type !== 'PA') return [];
                
                const connectedPAs = [];
                
                // 查找所有以此PA為終點的連接
                connections.forEach(conn => {
                    // 如果連接的起點是PA，且終點是當前PA
                    if (conn.end === this && conn.start.type === 'PA') {
                        connectedPAs.push({
                            name: conn.start.name,
                            x: conn.start.x,
                            y: conn.start.y
                        });
                    }
                });
                
                return connectedPAs;
            }

            // 獲取調整大小控制點
            getResizeHandle(x, y) {
                if (!selectedShapes.includes(this)) return null;
                
                const handleSize = 8;
                const handles = [
                    { type: 'corner', x: this.x + this.width - handleSize/2, y: this.y + this.height - handleSize/2 },
                    { type: 'right', x: this.x + this.width - handleSize/2, y: this.y + this.height/2 - handleSize/2 },
                    { type: 'bottom', x: this.x + this.width/2 - handleSize/2, y: this.y + this.height - handleSize/2 }
                ];

                for (const handle of handles) {
                    if (x >= handle.x && x <= handle.x + handleSize &&
                        y >= handle.y && y <= handle.y + handleSize) {
                        return handle.type;
                    }
                }
                return null;
            }
        }

        // 繪製連接線
        function drawConnections() {
            // 繪製所有已確認的連接
            connections.forEach(conn => {
                ctx.beginPath();
                ctx.moveTo(conn.start.x + conn.start.width/2, conn.start.y + conn.start.height/2);
                ctx.lineTo(conn.end.x + conn.end.width/2, conn.end.y + conn.end.height/2);
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // 繪製預覽連接線 - 當選中多個元件時
            if (selectedShapes.length >= 2) {
                ctx.beginPath();
                for (let i = 0; i < selectedShapes.length - 1; i++) {
                    const current = selectedShapes[i];
                    const next = selectedShapes[i + 1];
                    ctx.moveTo(current.x + current.width/2, current.y + current.height/2);
                    ctx.lineTo(next.x + next.width/2, next.y + next.height/2);
                }
                ctx.strokeStyle = '#FF3B30';
                ctx.lineWidth = 4;
                ctx.stroke();
            }
        }

        // 重繪整個畫布
        function redraw() {
            // 清除主畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 先繪製背景圖（不受縮放和位移影響）
            if (bgImage) {
                if (!bgImage.hasOwnProperty('displayWidth')) {
                    // 初始化背景圖片的尺寸和位置
                    const scale = Math.min(canvas.width / bgImage.width, canvas.height / bgImage.height);
                    bgImage.displayWidth = bgImage.width * scale;
                    bgImage.displayHeight = bgImage.height * scale;
                    bgImage.x = (canvas.width - bgImage.displayWidth) / 2;
                    bgImage.y = (canvas.height - bgImage.displayHeight) / 2;
                    bgCacheDirty = true; // 初始化時標記緩存需更新
                }
                
                // 檢查並更新背景緩存（如果需要）
                updateBgCache();
                
                // 使用緩存的背景畫布
                ctx.globalAlpha = 1;
                ctx.drawImage(bgCanvas, 0, 0);

                // 繪製背景調整控制點 (不受縮放影響)
                if (!isDragging && !isResizing && !isResizingBg) {
                    drawBgResizeHandles();
                }
            }
            
            // 保存當前狀態，為繪製可操作元素準備
            ctx.save();
            
            // 只對設計元素（圖形和連線）應用縮放和位移
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // 繪製可操作元素，確保在背景之上
            drawConnections();
            shapes.forEach(shape => shape.draw());
            
            // 恢復畫布狀態
            ctx.restore();
            
            // 繪製縮放比例指示器
            // 更新縮放百分比顯示
            document.getElementById('zoom-level').textContent = `${Math.round(scale * 100)}%`;
            
            // 保留原有的畫布縮放指示器（可選）
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 100, 25);
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px -apple-system, BlinkMacSystemFont';
            ctx.fillText(`縮放: ${Math.round(scale * 100)}%`, 15, 28);
            ctx.restore();
        }

        // 初始化背景緩存
        function updateBgCache() {
            if (!bgImage || !bgCacheDirty) return false;
            
            // 調整背景畫布大小以匹配主畫布
            bgCanvas.width = canvas.width;
            bgCanvas.height = canvas.height;
            
            // 先在背景畫布上繪製白色背景
            bgCtx.fillStyle = '#ffffff';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
            
            // 設置背景圖片的透明度
            bgCtx.globalAlpha = bgOpacity;
            
            // 保存當前狀態以應用旋轉
            bgCtx.save();
            
            // 移動到圖片中心點
            bgCtx.translate(bgImage.x + bgImage.displayWidth/2, bgImage.y + bgImage.displayHeight/2);
            
            // 應用旋轉
            bgCtx.rotate(bgRotation * Math.PI / 180);
            
            // 繪製圖片（從中心點偏移）
            bgCtx.drawImage(bgImage, -bgImage.displayWidth/2, -bgImage.displayHeight/2, bgImage.displayWidth, bgImage.displayHeight);
            
            // 恢復狀態
            bgCtx.restore();
            
            // 重置標記
            bgCacheDirty = false;
            return true;
        }

        // 新增TB箱按鈕事件
        document.getElementById('addTB').addEventListener('click', () => {
            const shape = new Shape('TB', canvas.width / 2, canvas.height / 2);
            saveState();
            shapes.push(shape);
            selectedShapes = [];
            redraw();
        }, { once: true });

        // 新增PA按鈕事件
        document.getElementById('addPA').addEventListener('click', () => {
            document.getElementById('add-pa-modal').style.display = 'flex';
            document.getElementById('pa-name-input').value = '';
            document.getElementById('pa-name-input').focus();
        });

        document.getElementById('cancel-add-pa').addEventListener('click', () => {
            document.getElementById('add-pa-modal').style.display = 'none';
        });

        document.getElementById('confirm-add-pa').addEventListener('click', () => {
            const paName = document.getElementById('pa-name-input').value.trim();
            if (paName) {
                const shape = new Shape('PA', canvas.width / 2, canvas.height / 2);
                shape.name = paName;
                saveState();
                shapes.push(shape);
                redraw();
            }
            document.getElementById('add-pa-modal').style.display = 'none';
        });

        document.getElementById('pa-name-input').addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('confirm-add-pa').click();
            } else if (e.key === 'Escape') {
                document.getElementById('cancel-add-pa').click();
            }
        });

        canvas.addEventListener('mousedown', function(e) {
            if (e.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 優先檢測可操作元件
            let hit = false;
            for (let i = shapes.length - 1; i >= 0; i--) {
                const shape = shapes[i];
                if (shape.isPointInside(x, y)) {
                    hit = true;
                    break;
                }
            }

            // 如果沒有點擊到任何元件且不是按住Shift鍵,則清除選擇
            if (!hit && !e.shiftKey) {
                selectedShapes = [];
                redraw();
            }
        });

        document.getElementById('delete').addEventListener('click', () => {
            if (selectedShapes.length > 0) {
                saveState();
                if (selectedShapes.length === 2) {
                    const start = selectedShapes[0];
                    const end = selectedShapes[1];
                    const hasConnection = connections.some(conn => 
                        (conn.start === start && conn.end === end) || 
                        (conn.start === end && conn.end === start));
                    
                    if (hasConnection) {
                        connections = connections.filter(conn => 
                            !((conn.start === start && conn.end === end) || 
                              (conn.start === end && conn.end === start)));
                    } else {
                        selectedShapes.forEach(shape => {
                            const index = shapes.indexOf(shape);
                            if (index > -1) {
                                shapes.splice(index, 1);
                                connections = connections.filter(conn => 
                                    conn.start !== shape && conn.end !== shape);
                            }
                        });
                    }
                } else {
                    selectedShapes.forEach(shape => {
                        const index = shapes.indexOf(shape);
                        if (index > -1) {
                            shapes.splice(index, 1);
                            connections = connections.filter(conn => 
                                conn.start !== shape && conn.end !== shape);
                        }
                    });
                }
                selectedShapes = [];
                redraw();
            }
        });

        document.getElementById('confirm').addEventListener('click', () => {
            if (selectedShapes.length === 2) {
                saveState();
                connections.push({
                    start: selectedShapes[0],
                    end: selectedShapes[1]
                });
                selectedShapes = [];
                redraw();
            }
        });

        document.getElementById('undo').addEventListener('click', () => {
            if (history.length > 0) {
                const previousState = history.pop();
                restoreState(previousState);
            }
        });

        document.getElementById('clear').addEventListener('click', () => {
            if (selectedShapes.length === 1) {
                saveState();
                const shape = selectedShapes[0];
                shape.name = '';
                redraw();
            }
        });

        document.getElementById('edit').addEventListener('click', () => {
            if (selectedShapes.length === 1) {
                const shape = selectedShapes[0];
                const container = document.querySelector('.name-input-container');
                const input = container.querySelector('.name-input');
                input.value = shape.name;
                container.style.display = 'block';
                container.style.left = (shape.x + canvas.offsetLeft) + 'px';
                container.style.top = (shape.y + canvas.offsetTop) + 'px';
                container.style.width = shape.width + 'px';
                input.focus();
                input.select();
                
                const handleInputChange = () => {
                    shape.name = input.value;
                    redraw();
                };

                const handleInputComplete = () => {
                    document.querySelector('.name-input-container').style.display = 'none';
                    redraw();
                };
                
                input.oninput = handleInputChange;
                input.onblur = handleInputComplete;
                input.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        handleInputComplete();
                    }
                }
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const currentTime = new Date().getTime();

            // 檢查是否點擊背景圖片的調整控制點或背景圖片本身 (直接使用座標，不受縮放影響)
            if (bgImage) {
                const bgHandle = isPointInBgResizeHandle(x, y);
                if (bgHandle) {
                    isResizingBg = true;
                    bgResizeHandle = bgHandle;
                    bgResizeStartX = x;
                    bgResizeStartY = y;
                    bgStartWidth = bgImage.displayWidth;
                    bgStartHeight = bgImage.displayHeight;
                    bgStartX = bgImage.x;
                    bgStartY = bgImage.y;
                    return;
                } else if (x >= bgImage.x && x <= bgImage.x + bgImage.displayWidth &&
                          y >= bgImage.y && y <= bgImage.y + bgImage.displayHeight) {
                    // 只有在不是縮放或平移模式時，才允許拖動背景
                    if (!isPanning) {
                        isDraggingBg = true;
                        bgResizeStartX = x;
                        bgResizeStartY = y;
                        bgStartX = bgImage.x;
                        bgStartY = bgImage.y;
                        return;
                    }
                }
            }

            for (const shape of shapes) {
                if (shape.isPointInside(x, y)) {
                    if (currentTime - lastClickTime < 300) {
                        selectedShapes = [];
                        currentShape = shape;
                        const container = document.querySelector('.name-input-container');
                        const input = container.querySelector('.name-input');
                        input.value = shape.name;
                        container.style.display = 'block';
                        container.style.left = (shape.x + canvas.offsetLeft) + 'px';
                        container.style.top = (shape.y + canvas.offsetTop) + 'px';
                        container.style.width = shape.width + 'px';
                        input.focus();
                        input.select();
                        
                        const handleInputChange = () => {
                            shape.name = input.value;
                            redraw();
                        };

                        const handleInputComplete = () => {
                            document.querySelector('.name-input-container').style.display = 'none';
                            redraw();
                        };
                        
                        input.oninput = handleInputChange;
                        input.onblur = handleInputComplete;
                        input.onkeypress = (e) => {
                            if (e.key === 'Enter') {
                                handleInputComplete();
                            }
                        }
                    } else {
                        const handle = shape.getResizeHandle(x, y);
                        if (handle) {
                            isResizing = true;
                            currentShape = shape;
                            resizeHandle = handle;
                            dragOffsetX = x;
                            dragOffsetY = y;
                        } else {
                            isDragging = true;
                            currentShape = shape;
                            dragOffsetX = x - shape.x;
                            dragOffsetY = y - shape.y;
                            const shapeIndex = selectedShapes.indexOf(shape);
                            if (shapeIndex === -1) {
                                selectedShapes.push(shape);
                            } else {
                                selectedShapes.splice(shapeIndex, 1);
                            }
                        }
                        redraw();
                    }
                    break;
                }
            }
            lastClickTime = currentTime;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isDraggingBg && bgImage) {
                const dx = x - bgResizeStartX;
                const dy = y - bgResizeStartY;
                
                // 直接移動背景圖片，不受縮放影響
                bgImage.x = bgStartX + dx;
                bgImage.y = bgStartY + dy;
                
                // 標記背景緩存需要更新
                bgCacheDirty = true;
                redraw();
                return;
            }

            if (isResizingBg && bgImage) {
                const dx = x - bgResizeStartX;
                const dy = y - bgResizeStartY;

                if (bgResizeHandle === 'corner') {
                    // 同時調整寬度和高度，不保持比例
                    const newWidth = bgStartWidth + dx;
                    const newHeight = bgStartHeight + dy;
                    bgImage.displayWidth = Math.max(50, newWidth);
                    bgImage.displayHeight = Math.max(50, newHeight);
                } else if (bgResizeHandle === 'right') {
                    // 只調整寬度
                    const newWidth = bgStartWidth + dx;
                    bgImage.displayWidth = Math.max(50, newWidth);
                } else if (bgResizeHandle === 'bottom') {
                    // 只調整高度
                    const newHeight = bgStartHeight + dy;
                    bgImage.displayHeight = Math.max(50, newHeight);
                } else if (bgResizeHandle === 'center') {
                    // 直接移動圖片位置，不改變大小
                    bgImage.x = bgStartX + dx;
                    bgImage.y = bgStartY + dy;
                }

                // 如果不是移動中心點，保持原始位置或居中
                if (bgResizeHandle !== 'center') {
                    // 使用原始位置而不是強制居中
                    if (bgResizeHandle === 'right') {
                        // 調整右邊時，左側固定
                        bgImage.x = bgStartX;
                    } else if (bgResizeHandle === 'bottom') {
                        // 調整下方時，上方固定
                        bgImage.y = bgStartY;
                    } else if (bgResizeHandle === 'corner') {
                        // 調整角落時，可選擇保持左上角固定
                        bgImage.x = bgStartX;
                        bgImage.y = bgStartY;
                    }
                }
                
                // 標記背景緩存需要更新
                bgCacheDirty = true;
                
                // 調整時顯示尺寸提示
                ctx.save();
                redraw();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(bgImage.x + 5, bgImage.y + 5, 180, 25);
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px -apple-system, BlinkMacSystemFont';
                ctx.fillText(`${Math.round(bgImage.displayWidth)} × ${Math.round(bgImage.displayHeight)}`, bgImage.x + 10, bgImage.y + 20);
                ctx.restore();
                return;
            }

            if (isResizing && currentShape) {
                const dx = x - dragOffsetX;
                const dy = y - dragOffsetY;
                dragOffsetX = x;
                dragOffsetY = y;

                const maxSize = 200; // 設置最大尺寸限制
                const minSize = 20;  // 設置最小尺寸限制

                switch (resizeHandle) {
                    case 'corner':
                        const newWidth = Math.min(maxSize, Math.max(minSize, currentShape.width + dx));
                        const newHeight = Math.min(maxSize, Math.max(minSize, currentShape.height + dy));
                        currentShape.width = newWidth;
                        currentShape.height = newHeight;
                        break;
                    case 'right':
                        const newRightWidth = Math.min(maxSize, Math.max(minSize, currentShape.width + dx));
                        currentShape.width = newRightWidth;
                        break;
                    case 'bottom':
                        const newBottomHeight = Math.min(maxSize, Math.max(minSize, currentShape.height + dy));
                        currentShape.height = newBottomHeight;
                        break;
                }
                redraw();
            } else if (isDragging && currentShape) {
                currentShape.x = x - dragOffsetX;
                currentShape.y = y - dragOffsetY;
                redraw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isResizingBg || isDraggingBg) {
                isResizingBg = false;
                isDraggingBg = false;
                bgResizeHandle = null;
                // 保存調整後的背景圖片狀態
                const bgState = {
                    displayWidth: bgImage.displayWidth,
                    displayHeight: bgImage.displayHeight,
                    x: bgImage.x,
                    y: bgImage.y
                };
                localStorage.setItem('bgState', JSON.stringify(bgState));
                
                // 標記背景緩存需要更新
                bgCacheDirty = true;
                redraw();
            }
            if (isResizing || isDragging) {
                saveState();
            }
            isDragging = false;
            isResizing = false;
            currentShape = null;
            resizeHandle = null;
        });

        redraw();

        // 同步位置說明表格的 input 值到 savedDesigns
        function syncLocationDescInputs() {
            const tableBody = document.getElementById('location-table-body');
            if (!tableBody) return;
            const rows = tableBody.querySelectorAll('tr');
            let currentDesignName = localStorage.getItem('currentDesignName');
            if (!currentDesignName) return;
            let locationDesc = {};
            if (savedDesigns[currentGroup][currentDesignName] && savedDesigns[currentGroup][currentDesignName].locationDesc) {
                locationDesc = savedDesigns[currentGroup][currentDesignName].locationDesc;
            }
            
            rows.forEach(row => {
                const tbName = row.querySelector('td:first-child').textContent;
                const paNameWithIndent = row.querySelector('td:nth-child(2)').textContent;
                const paName = paNameWithIndent.trimStart();
                const input = row.querySelector('td:nth-child(3) input');
                const tbLocationInput = row.querySelector('td:nth-child(4) input');
                
                if (!locationDesc[tbName]) {
                    locationDesc[tbName] = {};
                }
                
                // 初始化或更新位置說明資料
                if (!locationDesc[tbName][paName]) {
                    locationDesc[tbName][paName] = {
                        desc: '',
                        tbLocation: ''
                    };
                }
                
                // 更新位置說明
                if (input) {
                    locationDesc[tbName][paName].desc = input.value;
                }
                
                // 更新TB位置備註
                if (tbLocationInput) {
                    locationDesc[tbName][paName].tbLocation = tbLocationInput.value;
                }
            });
            
            // 寫回 savedDesigns
            if (savedDesigns[currentGroup][currentDesignName]) {
                savedDesigns[currentGroup][currentDesignName].locationDesc = locationDesc;
                localStorage.setItem(`savedDesigns_${currentGroup}`, JSON.stringify(savedDesigns[currentGroup]));
                
                // 如果當前有元件被懸停，更新提示框內容以反映新的位置說明
                if (currentHoveredShape) {
                    // 觸發滑鼠移動事件來更新提示框
                    const event = new MouseEvent('mousemove', {
                        clientX: parseInt(locationTooltip.style.left) - 15,
                        clientY: parseInt(locationTooltip.style.top) + 15,
                        bubbles: true
                    });
                    canvas.dispatchEvent(event);
                }
            }
        }

        // 修改大小調整滑桿的事件處理
        document.getElementById('shape-width').addEventListener('input', (e) => {
            if (selectedShapes.length > 0) {
                const width = parseInt(e.target.value);
                selectedShapes.forEach(shape => {
                    if (shape.type === 'TB') {
                        shape.width = width;
                    } else {
                        shape.width = width * 1.2; // PA寬度為TB的1.2倍
                    }
                });
                redraw();
            }
        });

        document.getElementById('shape-height').addEventListener('input', (e) => {
            if (selectedShapes.length > 0) {
                const height = parseInt(e.target.value);
                selectedShapes.forEach(shape => {
                    if (shape.type === 'TB') {
                        shape.height = height;
                    } else {
                        shape.height = height * 0.8; // PA高度為TB的0.8倍
                    }
                });
                redraw();
            }
        });

        // 當選擇形狀時更新滑桿的值
        canvas.addEventListener('mousedown', function(e) {
            // ... existing mousedown code ...
            
            // 更新滑桿的值
            if (selectedShapes.length === 1) {
                const shape = selectedShapes[0];
                document.getElementById('shape-width').value = shape.width;
                document.getElementById('shape-height').value = shape.height;
            }
        });

        // 滑鼠滾輪縮放事件
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            // 獲取滑鼠在畫布上的位置
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // 計算滑鼠在畫布座標系中的位置
            const canvasX = (mouseX - offsetX) / scale;
            const canvasY = (mouseY - offsetY) / scale;
            
            // 計算縮放比例變化
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = scale * delta;
            
            // 限制縮放範圍
            if (newScale >= 0.1 && newScale <= 5) {
                // 更新縮放比例
                scale = newScale;
                
                // 調整位移以保持滑鼠位置不變
                offsetX = mouseX - canvasX * scale;
                offsetY = mouseY - canvasY * scale;
                
                redraw();
            }
        });

        // 滑鼠中鍵拖曳事件 - 只影響設計圖而不影響背景
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // 中鍵
                e.preventDefault();
                isPanning = true;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                canvas.style.cursor = 'grabbing';
                
                // 確保背景不受設計圖拖曳影響
                if (isDraggingBg) {
                    isDraggingBg = false;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                
                // 只更新設計圖元素的偏移量，不影響背景
                offsetX += dx;
                offsetY += dy;
                
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                
                redraw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 1) {
                isPanning = false;
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'default';
            }
        });

        // 重置縮放和位移
        function resetView() {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            redraw();
        }

        // 在視窗大小改變時重置視圖
        window.addEventListener('resize', () => {
            resizeCanvas();
            resetView();
        });

        redraw();
    </script>
</body>
</html>